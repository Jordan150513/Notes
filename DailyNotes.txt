每天一个问题

3月16日

28、[※※※※※]苹果是如何实现autoreleasepool的？
http://www.jianshu.com/p/1b66c4d47cd7
是一个双向链表指针栈，
	autoreleasepoolpage，将需要autoreleasepool的对象加入到autoreleasepoolPage（双线链表的节点）中，然后压入栈。 这个还不确定，等到一定的时机，比如说，链表很长了，一个runloop即将要结束了
就会 将链表栈中存储的对象释放掉，然后链表pop操作。恢复。链表中的节点autoreleasepoolPage中会有一个标志 标志是哪个线程。
笔记是看了 但是没有理解 没有清楚：
 AutoreleasePool并没有单独的结构，而是由若干个AutoreleasePoolPage以双向链表的形式组合而成（分别对应结构中的parent指针和child指针）
AutoreleasePool 对应的 构造函数和 析构函数
更加全面一点的回答：
	autoreleasepool 结构体的定义：
extern "C" __declspec(dllimport) void * objc_autoreleasePoolPush(void);
extern "C" __declspec(dllimport) void objc_autoreleasePoolPop(void *);

struct __AtAutoreleasePool {
  __AtAutoreleasePool() {atautoreleasepoolobj = objc_autoreleasePoolPush();}
  ~__AtAutoreleasePool() {objc_autoreleasePoolPop(atautoreleasepoolobj);}
  void * atautoreleasepoolobj;
};
	构造函数和析构函数的特点（自动局部变量的构造函数是在程序执行到声明这个对象的位置时调用的，而对应的析构函数是在程序执行到离开这个对象的作用域时调用）
	
	单个自动释放池的执行过程就是objc_autoreleasePoolPush() —> [object autorelease] —> objc_autoreleasePoolPop(void *)。
根据源码可知：见NSObject.mm中
	AutoreleasePool的是通过AutoreleasePoolPage结构来实现的 
AutoreleasePoolPage的定义：

magic_t const magic;
    id *next;
    pthread_t const thread;
    AutoreleasePoolPage * const parent;
    AutoreleasePoolPage *child;
    uint32_t const depth;
    uint32_t hiwat;

是一个双向链表的节点，AutoreleasePool的内存结构就是一个双向链表

一个线程的autoreleasepool就是一个指针栈。
栈中存放的指针指向加入需要release的对象或者POOL_SENTINEL（哨兵对象，用于分隔autoreleasepool）。
栈中指向POOL_SENTINEL的指针就是autoreleasepool的一个标记。当autoreleasepool进行出栈操作，每一个比这个哨兵对象后进栈的对象都会release。
这个栈是由一个以page为节点双向链表组成，page根据需求进行增减。
autoreleasepool对应的线程存储了指向最新page（也就是最新添加autorelease对象的page）的指针。

magic：用来校验 AutoreleasePoolPage 的结构是否完整；
next：指向栈顶，也就是最新入栈的autorelease对象的下一个位置；
thread：指向当前线程；
parent：指向父节点
child：指向子节点
depth：表示链表的深度，也就是链表节点的个数
hiwat：表示high water mark（最高水位标记）


29、[※※]使用block时什么情况会发生引用循环，如何解决？
	self强引用block block中又强引用self，就会发生引用循环
	需要在block中更改的对象，需要经过__block,或者weak，转换成弱引用，避免引用循环。
一个对象中强引用了block，在block中又强引用了该对象，就会发射循环引用。	
解决方法是将该对象使用__weak或者__block修饰符修饰之后再在block中使用对象	

30、[※※]在block内如何修改block外部变量？
	添加__block修饰该外部变量，就可以在block中进行修改了
默认情况下，在block中访问的外部变量是复制过去的，即：写操作不对原变量生效。但是你可以加上 __block
来让其写操作生效，
为什么不可以，为什么用__block修饰就可以了？

Block不允许修改外部变量的值，这里所说的外部变量的值，指的是栈中指针的内存地址。
__block 所起到的作用就是只要观察到该变量被 block 所持有，就将“外部变量”在栈中的内存地址放到了堆中。
进而在block内部也可以修改外部变量的值。
变量进入block，实际就是已经改变了作用域。在几个作用域之间进行切换时，如果不加上这样的限制，变量的可维护性将大大降低。又比如我想在block内声明了一个与外部同名的变量，此时是允许呢还是不允许呢？只有加上了这样的限制，这样的情景才能实现。于是栈区变成了红灯区，堆区变成了绿灯区。


    __block int a = 0;
    NSLog(@"定义前：%p", &a);         //栈区
    void (^foo)(void) = ^{
        a = 1;
        NSLog(@"block内部：%p", &a);    //堆区
    };
    NSLog(@"定义后：%p", &a);         //堆区
    foo();

/*
 定义前：0x16fd01eb8 栈区
 定义后：0x1740334f8 堆区
 block内部：0x1740334f8 堆区
 */
“定义后”和“block内部”两者的内存地址是一样的，我们都知道 block 内部的变量会被 copy 到堆区，
“block内部”打印的是堆地址，因而也就可以知道，“定义后”打印的也是堆的地址。
__block将对象从栈区拷贝到堆区 block也在堆区域


31、[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？
	不需要吧？这个不确定。反正动画的时候 没有考虑 这个回答 是不对的
有些需要考虑 有些不需要考虑 单向强引用的不需要考虑，
系统的某些block api中，UIView的block版本写动画时不需要考虑，但也有一些api 需要考虑：

所谓“引用循环”是指双向的强引用，所以那些“单向的强引用”（block 强引用 self ）没有问题，比如这些：

[UIViewanimateWithDuration:durationanimations:^{ [self.superviewlayoutIfNeeded]; }];
这个是单向的，只有block强引用self self 并不强引用block

[[NSOperationQueuemainQueue]addOperationWithBlock:^{ self.someProperty= xyz; }];
同理 这个也是单向的

[[NSNotificationCenterdefaultCenter]addObserverForName:@"someNotification"object:nilqueue:[NSOperationQueuemainQueue]usingBlock:^(NSNotification* notification) {                                                    self.someProperty= xyz; }];
这个也是单向的
这些情况不需要考虑“引用循环”。

但如果你使用一些参数中可能含有 ivar 的系统 api ，如 GCD 、NSNotificationCenter就要小心一点：比如GCD 内部如果引用了 self，而且 GCD 的其他参数是 ivar，则要考虑到循环引用：
这个就是双向的 
__weak__typeof__(self) weakSelf = self;
dispatch_group_async(_operationsGroup, _operationsQueue, ^{__typeof__(self) strongSelf = weakSelf;
	[strongSelfdoSomething];
	[strongSelfdoSomethingElse];
} );

类似的：

__weak__typeof__(self) weakSelf = self;	
  _observer = [[NSNotificationCenterdefaultCenter]addObserverForName:@"testKey"object:nilqueue:nilusingBlock:^(NSNotification*note) {
__typeof__(self) strongSelf = weakSelf;
[strongSelfdismissModalViewControllerAnimated:YES];  
}];

self --> _observer --> block --> self 显然这也是一个循环引用。




32、[※※]GCD的队列（dispatch_queue_t）分哪两种类型？
	dispatch_global_queue 和 dispatch_main_queue 回答的是什么鬼东西👻
串行队列Serial Dispatch Queue ：The main queue是串行的， 用户队列 dispatch_queue_create 创建的 也是 串行的
并行队列Concurrent Dispatch Queue ：Global queue 是并行队列

GCD中有三种队列类型：

The main queue: 与主线程功能相同。实际上，提交至main queue的任务会在主线程中执行。
main queue可以调用dispatch_get_main_queue()来获得。因为main queue是与主线程相关的，所以这是一个  串行队列。

Global queues: 全局队列是  并发队列， 并由整个进程共享。进程中存在三个全局队列：高、中（默认）、低三个优先级队列。
可以调用dispatch_get_global_queue函数传入优先级来访问队列。

用户队列: 用户队列 (GCD并不这样称呼这种队列, 但是没有一个特定的名字来形容这种队列，所以我们称其为用户队列)
是用函数 dispatch_queue_create 创建的队列. 这些队列是串行的。正因为如此，它们可以用来完成同步机制, 有点像传统线程中的mutex。



33、[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）
	用dispatch_group,会等grou执行完之后，再执行后面的。 这个算是对的
dispatch_group_t
内部用dispatch_group_async

34、[※※※※]dispatch_barrier_async的作用是什么？
	栅栏 栅栏要等栅栏前面的执行完了才执行栅栏，栅栏里面完全执行完了，再执行栅栏后面的，栅栏里面可同步 可异步，这个是异步执行栅栏里面的。

35、[※※※※※]苹果为什么要废弃dispatch_get_current_queue？
	好像是因为同步阻塞会导致死锁
参考： http://blog.csdn.net/yiyaaixuexi/article/details/17752925

可重入，
来自维基百科：若一个程序或子程序可以“安全的被并行执行(Parallel computing)”，则称其为可重入（reentrant或re-entrant）的。
即当该子程序正在运行时，可以再次进入并执行它（并行执行时，个别的执行结果，都符合设计时的预期）。


36、[※※※※※]以下代码运行结果如何？
- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
我亲测运行报错了，这是为啥？？？


37、[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？
   addObserver:<#(nonnull NSObject *)#> forKeyPath:<#(nonnull NSString *)#> options:<#(NSKeyValueObservingOptions)#> context:<#(nullable void *)#>]
    第一个参数：指明是给谁添加观察者
    第二个参数： <#(nonnull NSString *)#> 指明keypath
    第三个参数：NSKeyValueObservingOptions 有三个枚举值 initial new old
    第四个参数： <#(nullable void *)#> context
    context:需要传递的对象是一个(void *)类型的数据，这是一个C类型的对象，我们需要做的就是将id类型的对象转成C类型。
观察者模式：


38、[※※※]如何手动触发一个value的KVO

39、[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？

40、[※※※※]KVC的keyPath中的集合运算符如何使用？

41、[※※※※]KVC和KVO的keyPath一定是属性么？

42、[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？

43、[※※※※※]apple用什么方式实现对一个对象的KVO？

44、[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?

45、[※※※※※]IB中User Defined Runtime Attributes如何使用？

46、[※※※]如何调试BAD_ACCESS错误

47、[※※※]lldb（gdb）常用的调试命令？
	watch point、 p、 po、
      watchpoint set v string_weak_



3月14日

添加了观察者 但是没有触发观察者的方法，为什么会这样的？原因是啥？

参考网上大神总结的问题 我搬到这里学习
问题：
1、[※]@property中有哪些属性关键字？
	noatomic weak strong copy assign 

2、[※]weak属性需要在dealloc中置nil么？
	不需要, weak属性，在对象销毁的时候，weak属性会置为nil

3、[※※]@synthesize和@dynamic分别有什么作用？
	更准确一点的是：
	@synthesize，在你没有手动去实现set get这两个方法时，编译器自动生成setter和getter的方法。
	@dynamic，告诉编译器不需要帮你生成setter和getter方法，你会实现setter和getter方法，或者存取方法在运行时的时候动态绑	定。
	@synthesize date=_date;给属性绑定指明实例变量的名字。

4、[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？
	没有指定 默认是atomic 默认的是strong 还是weak？？是strong，猜测是对的
	没有写默认的是 strong, atomic, readwrite

5、[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？
	
	如果使用Strong，可能会有两个影响，一个是
	Mutable是其子类，如果是赋值给了一个Mutabel的子类，子类不能进行相应的操作方法。这个说法不对的。
	更准确一点的说法：
	用copy的目的是为了让本对象的属性不受外界影响,体现String类型的封装性，如果用strong，如果指向的是一个可变的对象，那么属性	就有可能被外部修改了。破坏了其封装性。

6、[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？
	不会吧？不确定 @synthesize 合成实例变量的规则

	更加准确一点的说法是：
	完成属性定义后，编译器会自动编写访问这些属性所需的方法，此过程叫做“自动合成”( autosynthesis)。这个过程由编译 器在编译期	执行，所以编辑器里看不到这些“合成方法”(synthesized method)的源代码。除了生成方法代码 getter、setter 之外，编译器还	要自动向类中添加适当类型的实例变量，并且在属性名前面加下划线，以此作为实例变量的名字。也可以在类的实现代码里通过 		@synthesize语法来指定实例变量的名字.
	@property有两个对应的词，一个是@synthesize，一个是@dynamic。	
	如果@synthesize和@dynamic都没写，那么默认的就是@syntheszie var = _var;
	
	假如一个属性被声明为@dynamic var，然后你没有提供@setter方法和@getter方法，编译的时候没问题，但是当程序运行到		instance.var = someVar，由于缺setter方法会导致程序崩溃；或者当运行到 someVar = var时，由于缺getter方法同样会导致	崩溃。编译时没问题，运行时才执行相应的方法，这就是所谓的动态绑定。

	总结下@synthesize合成实例变量的规则，有以下几点：

	1）如果指定了成员变量的名称,会生成一个指定的名称的成员变量,

	2）如果这个成员已经存在了就不再生成了.

	3）如果是 @synthesize foo; 还会生成一个名称为foo的成员变量，也就是说：如果没有指定成员变量的名称会自动生成一个属性同名	的成员变量。

	4）如果是 @synthesize foo = _foo; 就不会生成成员变量了.

	假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？ 不会。
			
	什么情况下不会autosynthesis（自动合成）？需要用到@synthesize，也就是需要用@synthesize的场景

	1）同时重写了setter和getter时

	2）重写了只读属性的getter时

	3）使用了@dynamic时

	4）在 @protocol 中定义的所有属性

	5）在 category 中定义的所有属性

	6）重载的属性

	当你在子类中重载了父类中的属性，你必须 使用@synthesize来手动合成ivar。

	除了后三条，对其他几个我们可以总结出一个规律：	
	当你想手动管理@property的所有内容时，你就会尝试通过实现@property的所有“存取方法”（the accessor methods）或者使用	@dynamic来达到这个目的，这时编译器就会认为你打算手动管理@property，于是编译器就禁用了autosynthesis（自动合成）。
	借助@synthesize来手动合成ivar。

7、[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？见上题答案后部分
	同步锁？什么鬼，搞混了。
	1、有时候 我们不用自动合成的，而是自己手动编写的set get方法，那么就需要@synthesize来手动合成ivar
	2、readonly的property，我们自己定义get方法，这个也不能是自动合成的，也需要通过@synthesize来手动合成ivar
	3、指明用dynamic，肯定也不会自动合成，就需要通过@synthesize来手动合成ivar
	在 自动合成不能实现的时候 借助@synthesize来手动合成ivar

8、[※※]objc中向一个nil对象发送消息将会发生什么？
	是安全的不会崩溃
	
	更加充分一点的说法：
	向nil发送了消息；OC中nil是被当做0定义的。也就是说runtime要去获取这个nil的信息，会去读取内存中0的位置，这肯定是不允许的，	会返回nil，0，0.0等数据，根据返回值类型。

	需要区别的是 僵尸对象。僵尸对象并不是nil，僵尸对象是你的object被销毁或者用于其他地方了，但是指向它的指针还在。会发生向一个	object发送一个它没有的方法。

9、[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？
	[obj foo]的本质是调用了objc_msgSend(obj，foo)
	去obj的对应的类中找方法
	先找缓存，找不到再去找方法列表，
	再找父类，如此向上传递。
	最后再找不到就要转发。

10、[※※※]什么时候会报unrecognized selector的异常？
	给一个对象发送消息，在该对象的方法表中（如果是实例方法，就在其类的方法表中找不到对应的方法，如果是类方法，就在元类的方法表中	查找）找不到对应的消息。 牵涉到消息的转发机制。这里还不是很熟悉。
	
	更详细一点的说法：
	objc在向一个对象发送消息时，runtime库会根据对象的isa指针找到该对象实际所属的类，然后在该类中的方法列表以及其父类方法列表	中寻找方法运行，如果，在最顶层的父类中依然找不到相应的方法时，程序在运行时会挂掉并抛出异常unrecognized selector sent 	to XXX 。但是在这之前，objc的运行时会给出三次拯救程序崩溃的机会：

	Method resolution
	objc运行时会调用+resolveInstanceMethod:或者 +resolveClassMethod:，让你有机会提供一个函数实现。如果你添加了函数，	那运行时系统就会重新启动一次消息发送的过程，否则 ，运行时就会移到下一步，消息转发（Message Forwarding）。

	Fast forwarding
	如果目标对象实现了-forwardingTargetForSelector:，Runtime 这时就会调用这个方法，给你把这个消息转发给其他对象的机会。
	只要这个方法返回的不是nil和self，整个消息发送的过程就会被重启，当然发送的对象会变成你返回的那个对象。否则，就会继续Normal 		Fowarding。
	这里叫Fast，只是为了区别下一步的转发机制。因为这一步不会创建任何新的对象，但下一步转发会创建一个NSInvocation对象，所以相	对更快点。

	Normal forwarding
	这一步是Runtime最后一次给你挽救的机会。首先它会发送-methodSignatureForSelector:消息获得函数的参数和返回值类型。如	果-methodSignatureForSelector:返回nil，Runtime则会发出-doesNotRecognizeSelector:消息，程序这时也就挂掉了。如	果返回了一个函数签名，Runtime就会创建一个NSInvocation对象并发送-forwardInvocation:消息给目标对象。

11、[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）
	这个确实不知道，其实是知道的，要自己好好整理一下

	参照instance class metaclass的图 显示了isa的关系和继承的关系
	1）所有父类的成员变量和自己的成员变量都会存储在该 实例对象 的存储空间之中
	2）每一个对象的内部都有一个isa指针，实例对象存的是指向其类的指针，类对象存的是指向其元类的指针。
	  类对象中存放着本身对象的	
	a,对象方法列表（对象能够接收的消息列表，保存在它所对应的类对象中）
	b,成员变量的列表。
	c,属性列表。
	类对象内也有一个isa指针指向元对象（meta class），元对象内部存放的是类方法列表，类对象内部还有一个superclass的指针，指向他的父类对象

见源码 runtime.h中有定义：

// 假的，真正的实现见 objc-runtime-new
struct objc_class {
    Class isa  OBJC_ISA_AVAILABILITY;

#if !__OBJC2__
    Class super_class                                        OBJC2_UNAVAILABLE;
    const char *name                                         OBJC2_UNAVAILABLE;
    long version                                             OBJC2_UNAVAILABLE;
    long info                                                OBJC2_UNAVAILABLE;
    long instance_size                                       OBJC2_UNAVAILABLE;
    struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
    struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
    struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
    struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
#endif

} OBJC2_UNAVAILABLE;


根据源码 才能说话 别只会看别人的分析，
每一个NSObject对象都是objc_class类型的
1、objc_class类里面有superclass的指针 指明继承关系
2、缓存 缓存了SEL和IMP的对应关系，发送消息的时候 先来缓存里找，然后再去方法列表里面找
3、还有一个标志的变量 bits 里面存了各种的标志信息

objc-runtime-new中真正的定义：

struct objc_class : objc_object {
//    Class ISA;    // 别疑惑，确实是被apple注释了。
                    // 原来是用来存储元类信息的，但是现在不是了，因为 objc_class 继承自 objc_object
                    // 元类（也就是类的类型）被存在了 objc_object 中的 isa_t isa 结构体中
    Class superclass; // 指向当前类的父类
    cache_t cache;    // cache 缓存 sel 和 imp 的对应关系，加速方法的调用  // formerly cache pointer and vtable
    class_data_bits_t bits; // class_rw_t * plus custom rr/alloc flags
                        // 存储类的方法、属性、遵循的协议等信息，注意是值类型的
                        // objc_class 中对 class_data_bits_t 中的很多方法重新做了封装
                        // 对外界隐藏了 class_data_bits_t

    // 取得 bits 中存的 data，就是 class_data_bits_t 里的 bits 中的 data 部分
    // 在 realized 之前，data 存的是 ro，用的时候需要强转为 class_ro_t
    // 在 realized 之后，存的才是 rw
    class_rw_t *data() { 
        return bits.data();
    }
    
    // 设置 bits 中的 data 部分
    void setData(class_rw_t *newData) {
        bits.setData(newData);
    }

    // 设置 bits 中的 class_rw_t 结构体中存的 flag
    // 本质上是按位或，将指定的位置变为 1
    void setInfo(uint32_t set) {
        // 既没有 realized ，又没有 future ，说明 class 还没有准备好，后面的操作都做不了
        assert(isFuture()  ||  isRealized());
        data()->setFlags(set);
    }

    // 清空 bits 中的 class_rw_t 结构体中存的 flag
    // 本质上是按位异或，将指定的位置变为 0
    void clearInfo(uint32_t clear) {
        assert(isFuture()  ||  isRealized());
        data()->clearFlags(clear);
    }

    // set and clear must not overlap （不能重叠）
    // 既 set 又 clear，按位或和按位异或一起做，但是更新的位置不能重叠，不然就有歧义了
    void changeInfo(uint32_t set, uint32_t clear) {
        assert(isFuture()  ||  isRealized());
        assert((set & clear) == 0);
        data()->changeFlags(set, clear);
    }
}
//objc_class 定义结束 太多了 类里面 太多东西了 只取一些重要的说吧









12、[※※※※]一个objc对象的isa的指针指向什么？有什么作用？
	实例对象的isa指向它的类，类对象的isa指向其元类

13、[※※※※]下面的代码输出什么？

@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
	输出：
	TestDemo[541:332834] Son
	TestDemo[541:332834] Son
	这个应该怎么解释调用过程呢？？？
	iOS子类中调用[super class]为何会输出子类类型？
	对方法的调用是通过发送消息来完成的。
	1）也就是说使用 [self class] 时，会使用obj_msgSend（id theReceiver, SEL selector, ...）函数向Receiver来发送消息。
	而使用 [super class] 时，会使用obj_msgsendSuper(...)函数向Receiver来发送消息。
Receiver 都是当前的子类self son，所以
	2). [self class]和[super class]都会找到 NSObject中class方法

	3). 当[super class]找到NSObject中的class方法以后，仍然会使用obj_msgSend(receiver, @selector(class))函数，因为receiver不变，所以输出的结果仍旧是DetailViewController
	[super class]找到NSObject中class方法以后，reciever不变实际上是因为
	super只是一个“编译器指示符”，它和self指向的是相同的receiver。


14、[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）
	selector的本质就是一个字符串，方法列表中存储着方法的名字，方法的实现IMP，方法的参数列表。
	类方法：
	会通过类的isa指针到类的元类中的方法表(method_list中进行)查找，在method_list中存储的方法结构体中有IMP指针

	实例方法：
	会通过selector到实例对象isa指向的类方法表（method_list）中寻找对应的方法，映射对 key-value 找到对应的方法结构体重有IMP指针

	这个需要到源码中找到相应的源码
	
	在寻找IMP的时候有两个主要的方法 参见TestIMP Demo
	IMP class_getMethodImplementation(Class cls, SEL name);
	IMP method_getImplementation(Method m)
	
	objc-class.mm文件中实现
	/***********************************************************************
 	* object_getMethodImplementation.
 	**********************************************************************/
	//  取得 obj 对象中的指定 SEL 对应的方法的函数指针
	// 这个寻找IMP的是在哪里调用的？？
//在NSObject.mm + (IMP)methodForSelector:(SEL)sel 和 + (IMP)methodForSelector:(SEL)sel  中调用
// objc-weak中也有调用

IMP object_getMethodImplementation(id obj, SEL name)
{
    // 先取 obj 对象的类，
    // 如果 obj 对象是 nil，那么类也是 nil，class_getMethodImplementation 返回的也是 nil
    Class cls = (obj ? obj->getIsa() : nil);
    // 然后调用 class_getMethodImplementation 函数从 cls 类中查找指定的 SEL
    return class_getMethodImplementation(cls, name);
}

在NSObject.mm中调用
+ (IMP)methodForSelector:(SEL)sel {
    if (!sel) [self doesNotRecognizeSelector:sel];
    return object_getMethodImplementation((id)self, sel);
}

// 通过 sel 找到对应的方法实现的函数指针
- (IMP)methodForSelector:(SEL)sel {
    if (!sel) [self doesNotRecognizeSelector:sel];
    return object_getMethodImplementation(self, sel);
}

struct objc_method {
    SEL method_name                                      
    char *method_types                                       
    IMP method_imp                                           
}
objc_method 结构体中有IMP 指针

15、[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？
	不需要，会在对象销毁的时候，会移除关联的对象，就被释放掉了。

16、[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？
	类方法存储在元类中的方法列表里，通过类的isa到元类的方法列表里取查找
	实例方法存储在类的方法列表里，通过实例的isa到类的方法列表里去查找

	1，类方法是属于类对象的 
	2，类方法只能通过类对象调用 
	3，类方法中的self是类对象 
	4,类方法中不能访问成员变量 
	5，类方法可以调用其他的类方法 
	6，类方法中不能直接调用对象方法

	1，实例方法是属于实例对象的 
	2，实例方法只能通过实例对象调用，
	3，实例方法中的self是实例对象 
	4，实例方法中可以访问成员变量 
	5，实例方法中直接调用实例方法
	6，实例方法中可以直接调用类方法(通过类名)

17、[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？
	消息转发，当前对象的方法列表里，没有对应的方法（发送的消息），就会调用。。。。后面就又不清楚了。不仅要清楚实现过程，还需要清楚源码的实现。
	当对象没有实现某个方法 ，会调用这个函数进行方法转发。（某方法对应的IMP没找到，会返回这个函数的IMP去执行）
消息转发的步骤：
1.调用resolveInstanceMethod:方法，允许用户在此时为该Class动态添加实现。如果有实现了，则调用并返回。如果仍没实现，继续下面的动作。

2.调用forwardingTargetForSelector:方法，尝试找到一个能响应该消息的对象。如果获取到，则直接转发给它。如果返回了nil，继续下面的动作。

3.调用methodSignatureForSelector:方法，尝试获得一个方法签名。如果获取不到，则直接调用doesNotRecognizeSelector抛出异常。

4.调用forwardInvocation:方法，将地3步获取到的方法签名包装成Invocation传入，如何处理就在这里面了。

如果直接调用这个方法，就算实现了想调用的方法，也不会被调用，会直接走消息转发步骤。



18、[※※※※※]runtime如何实现weak变量的自动置nil？
	那个方法叫什么来这 weak_clean_nolock（）

	runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。

19、[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
	不能向编译后得到的类中增加实例变量，但是可以向运行时创建的类中，动态的增加属性，但是增加不了实例变量。

不能向编译后得到的类中增加实例变量；
能向运行时创建的类中添加实例变量；

原因如下：

因为编译后的类已经注册在 runtime 中，类结构体中的 objc_ivar_list 实例变量的链表 和 instance_size 实例变量的内存大小已经确定，同时runtime 会调用 class_setIvarLayout 或 class_setWeakIvarLayout 来处理 strong weak 引用。所以不能向存在的类中添加实例变量；

运行时创建的类是可以添加实例变量，调用 class_addIvar 函数。但是得在调用 objc_allocateClassPair 之后，objc_registerClassPair 之前，原因同上。

向运行时创建的类中添加实例变量的demo————见demo————

另 牵涉出 runtime动态创建类、添加方法、添加实例变量

20、[※※※]runloop和线程有什么关系？
	一一对应的关系 只说一个一一对应，开玩笑呢 相当于啥都没有说。
	每个线程，包括程序的主线程（main thread）都有与之相应的run loop对象。
	runloop和线程的关系：
	主线程的run loop默认是启动的, 子线程的runloop默认是不开启的,需要我们自己手动开启循环; 
程序启动后会有一个如下的main()函数 启动主循环，会为main thread设置一个NSRunLoop对象，这就解释了：为什么我们的应用可以在无人操作的时候休息，需要让它干活的时候又能立马响应。
runloop执行完毕之后,就会进入休眠 , 只有在某个情况下触发了,才会再次调用;

21、[※※※]runloop的mode作用是什么？
	
22、[※※※※]以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
	Time加入的mode 优先级太低了，将这个timer加入到一个commonmode中

23、[※※※※※]猜想runloop内部是如何实现的？
	就老老实实 按照大牛写的说 但是具体说，还需要总结 整理一下

24、[※]objc使用什么机制管理对象内存？
	自动引用计数 ARC 之前用MRC java是垃圾回收机制，iOS没有垃圾回收机制

25、[※※※※]ARC通过什么方式帮助开发者管理内存？
	引用计数，谁创建 谁管理，谁负责释放，强引用的时候引用计数retain，+1，不需要的时候release引用计数-1，引用计数为0 的时候 回收对象内存。
	在编译期，ARC用的是更底层的C接口实现的retain/release/autorelease，这样做性能更好，也是为什么不能在ARC环境下手动retain/release/autorelease，同时对同一上下文的同一对象的成对retain/release操作进行优化（即忽略掉不必要的操作）；

26、[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）
	释放池drain的时候释放

分两种情况：
手动干预释放时机、系统自动去释放。

1.手动干预释放时机--指定autoreleasepool 就是所谓的：当前作用域大括号结束时释放。
系统自动去释放--不手动指定autoreleasepool
2.Autorelease对象出了作用域之后，会被添加到最近一次创建的自动释放池中，并会在当前的 runloop 迭代结束时释放。

 所有 autorelease 的对象，在出了作用域之后，会被自动添加到最近创建的自动释放池中。
 在一次完整的运行循环结束之前，会被销毁。

如果在一个vc的viewDidLoad中创建一个 Autorelease对象，那么该对象会在 viewDidAppear 方法执行前就被销毁了。
在没有手加Autorelease Pool的情况下，Autorelease对象是在当前的runloop
迭代结束时释放的，而它能够释放的原因是系统在每个runloop迭代中都加入了自动释放池Push和Pop

http://www.jianshu.com/p/1ddd0603d7e1
这个问题，这个博客讲解的不错

27、[※※※※]BAD_ACCESS在什么情况下出现？
	访问野指针 对一个已经释放的对象执行了release、访问已经释放对象的成员变量或者发消息。
	数组越界 ？test一下 不是 bad access 是NSRangeException 
	死循环 不熟悉 没有遇到



1、objc中向nil发送消息，是安全的 不会崩溃。

3月13日
LH DD 题：
1、通知中心的原理
2、算法121abccba找出字符串中最长的回文数
3、犯人喝毒酒逻辑题
4、网络请求缓存设计web
5、为什么category可以添加方法不能添加成员变量
6、热更新替代方案一 不是苹果不让用了么？
7、autoreleasepool的使用场景
8、sel和imp的区别
9、http多次请求会建立几个tcp连接
10、meta class是什么 它的作用是什么？
11、imageNamed：对象什么时候释放
12、super.class打印
13、main函数之前 程序做了什么
14、如何设定一个指定线程数目的线程池


BD T：
1、流量监控怎么做？
2、动画
3、基础和原理


3月13日
1、代码规范的问题：

a. 注意 不要将驼峰命名法和下划线命名法 混合使用 要规范使用
b.如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 do，does 这种多余的关键字，动词本身的暗示就足够了。
c.方法中不要用 with 来连接两个参数: withAge: 应当换为age:
d.初始化方法的 全能初始化方法的 规范，所有的初始化方法最终都是通过调用全能初始化方法实现的。其他的初始化方法的参数是全能初始化方法的子集。
e.枚举的定义 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，例如：
//定义一个枚举 枚举的名字是 CYLSex 执行枚举的类型是 NSInteger
typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};
f.要用NSInter 而不是int 用CGFloat 而不是float，要用NSFoundation框架的东西，不要直接使用。
g.拒绝中英文混合使用
h.不管是MVC 还是MVVP 。业务逻辑放在业务逻辑应该的地方，比如说控制器里面，不要放在对象类中，比如说，不要把登陆实现方法写在model
中。


先总结这么多 ，以后再慢慢加




3月10日
带着问题去学习，感觉会效率更加好一些
加油 
根据这个 带着这个去学习：
http://blog.sunnyxx.com/2015/07/04/ios-interview/

1、@property 后面可以有哪些修饰符？
	noatomic/atomic strong/weak/assign/copy 指定setter getter 

2、什么情况使用 weak 关键字，相比 assign 有什么不同？
	特点：weak和assign 既不保留新值，也不释放旧值,
	什么情况下使用weak关键字：在为了避免循环引用的地方，使用weak，可以避免循环引用，比如说delegate。
  	weak 关键字 非拥有关系 用来修饰NSObject对象 assign针对的是基本数据类型 NSInter Float等
assign修饰的基本数据类型对象，在释放之后，并不会置为nil，但是基本数据类型是在栈中分配的存储空间，栈的空间管理，是由系统自行处理，释放或者分配，不会造成野指针。不会崩溃。weak修饰的对象是在堆上申请的，对象释放的时候，会被置为nil。如果没有被置为nil就是一个野指针，还指向堆中的某个地方，当下次用到堆中这个地址的时候，就会崩溃了，weak 在对象被释放之后，会置为nil，是安全的，不会造成野指针。不会引起崩溃。

3、怎么用 copy 关键字？
	是用来修饰NSString类型的 会使引用计数加1，
Strong会使两个指针 指向同一个地址
copy会在内存里拷贝一份数据 两个指针 指向不同的地址
NSString用copy，经常用copy的特质来保护其封装性，NSString NSDictionary NSArray经常使用copy来修饰属性，是因为他们有对应的Mutable类型，为了确保来赋值的时候，有可能是赋给子类mutable，所以为了防止发生意外的改变内容，拷贝一份不可变的字符串，确保字符串中的值不会在对象不知道的情况下 进行更改，也就是在set的时候进行了更改。

在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行。


4、这个写法会出什么问题： @property (copy) NSMutableArray *array;
	将NSMutableArray 声明成了copy修饰的特性的 类的实例 对NSMutableArray 类型的array 不是拥有的关系。
是又拷贝了一份 又用一个指针指向现在拷贝的这一份拷贝，拷贝的这一份是NSArrya，就会出现 之前那个指针指向的再去操作 就会被释放了 或者 数据不一致？？这个回答可以吗？准确不？不对 要说到 copy的是一个不可变的NSarray，所以，是不能记性操作的。

两个问题：
1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；
2、使用了 atomic 属性会严重影响性能 ；
如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic)
.h
@property (nonatomic, copy) NSMutableArray *mutableArray;

.m
NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;   //这里set方法，是copy了一个不可变的NSArray,所以接下来进行操作的时候，就会崩溃。
[self.mutableArray removeObjectAtIndex:0];


 
5、如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
	copy修饰的属性的setter方法的实现 MRC的实现方式？??
	@property（atomic,copy）NSString * stringC;
	-(void)setStringC:(NSString *)string{
	        [string retain];
		[_string release];
		_string = [string copy]; // 这里不对了  忘记了 retain新值 释放旧值 赋值新值？？？
	}

见这个https://dayon.gitbooks.io/-ios/content/chapter5.html  ——————————gegege—————我是分割线—————
就是让自己的类有copy功能，
让类遵守<NSCopying>协议，重写- (id)copyWithZone:(NSZone *)zone方法，如果还有其他的需要深度拷贝的内容，需要注意，采用深度拷贝 相应的数据集合。
浅拷贝：
- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self class] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    return copy;
}

浅拷贝拷贝(包括一个数据集合)：
- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self class] allocWithZone:zone]
                     initWithName:_name
                     age:_age
                     sex:_sex];
    copy->_friends = [_friends mutableCopy];
    return copy;
}

深拷贝：
- (id)deepCopy {
    CYLUser *copy = [[[self class] allocWithZone:zone]
                     initWithName:_name
                     age:_age
                     sex:_sex];
    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                             copyItems:YES];
    return copy;
}


关于 如何重写带copy关键的字的setter

- (void)setName:(NSString *)name {
    //[_name release];  //MRC
    _name = [name copy];
}

这里有一点：
- (void)setName:(NSString *)name {
    if (_name != name) {
        //[_name release];//MRC
        _name = [name copy];
    }
}
不要在 setter 里进行像 if(_obj != newObj) 这样的判断。（该观点参考链接： How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure ）



更加进一步
6、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的
	声明 成员属性 在类的存储管理中的存储策略 iva 是实例变量 _变量名字 
实例变量存储在类的什么地方，属性存储在类的什么地方，属性跟实例变量有怎样的关系？

@property的本质是声明了一个属性变量

实例变量 和 属性有什么区别？
有时候 ？？什么时候？属性变量会自动生成一个与属性变量对应的实例变量， 也就是下划线开头的变量，但是如果重写的set get方法，就不会自动为属性变量生成其对应的实例变量了。
实例变量是在实例中以偏移量的方式存储的，有一个实例变量表，里面已偏移量的方式，存储着实例变量。
属性呢？ 怎么存储在类的存储结构中？

@property的本质：
@property ＝ ivar + getter + setter
property有两大概念 ivar(实例变量)  和 存取方法 setter getter

7、@protocol 和 category 中如何使用 @property
通过关联属性 给category添加 使用 @property 增加属性




8、runtime 如何实现 weak 属性  这个比较难 不好说 还是去源码里面找答案吧

runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。

参照源码中 objc_storeWeak()方法的实现

weak修饰的指针 是有默认的值的 默认的nil，也就是初始的值是nil


有关元类的：
元类里面存着类方法列表 给类发消息 会通过这个类isa到元类的方法列表里取查找方法。
当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找
当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找
所以这个也就验证了 isa的指向 实例对象的isa指向了类 类的isa指向了其元类

3月9日

1、JsonModel的实现 实现原理是什么 三方内部 各个负责什么 做什么工作
    核心就是用class_copyPropertyList得到类的属性列表，再遍历列表，
对每一个属性：
property_getName(property); 获取model类的每一个成员属性的名字
用property_getAttributes得到每个成员属性的属性的类型，
然后 存储在JSONModel中的 JSONModelClassProperty* p 中

最后用kvc，接可以得到所有的值。

使用的比较关键的方法
objc_property_t *properties = class_copyPropertyList(class, &propertyCount);
property_getName(property); // 获取属性的名字
property_getAttributes(property); // 获取属性的属性


主要实现 在JSONModel.m中 除了这个 还有比较重要的几个对象类
JSONKeyMapper 主要做啥？
JSONModelClassProperty 自定义的属性类型
/** Block, which takes in a property name and converts it to the corresponding JSON key name */
这个block 把一个属性名字 转换成的相应的 JSON key
@property (readonly, nonatomic) JSONModelKeyMapBlock modelToJSONKeyBlock;
2、


3月8日
2、
先好好想一想，想清楚了 再去动手做，二超经常这样跟我说 MT面试的时候，也是给我的中肯的提示，可见 我真的需要 遇到问题的时候，先好好想一想，想清楚了，再动手去做。没有想清楚就去做，会乱糟糟。

1、要知道Podfile.lock的作用，先要看看Podfile.lock是啥，里面有啥，才能知道他的作用。
首先，我们先来看看 AsyncDisplayKitCollectionView Demo中的Podfile文件中的内容
 cat Podfile.lock
PODS:
  - AsyncDisplayKit (2.1):
    - AsyncDisplayKit/PINRemoteImage (= 2.1)
  - AsyncDisplayKit/Core (2.1)
  - AsyncDisplayKit/PINRemoteImage (2.1):
    - AsyncDisplayKit/Core
    - PINRemoteImage/iOS (= 3.0.0-beta.7)
    - PINRemoteImage/PINCache
  - PINCache (3.0.1-beta.2):
    - PINCache/Arc-exception-safe (= 3.0.1-beta.2)
    - PINCache/Core (= 3.0.1-beta.2)
  - PINCache/Arc-exception-safe (3.0.1-beta.2):
    - PINCache/Core
  - PINCache/Core (3.0.1-beta.2)
  - PINRemoteImage/Core (3.0.0-beta.7)
  - PINRemoteImage/iOS (3.0.0-beta.7):
    - PINRemoteImage/Core
  - PINRemoteImage/PINCache (3.0.0-beta.7):
    - PINCache (= 3.0.1-beta.2)
    - PINRemoteImage/Core

DEPENDENCIES:
  - AsyncDisplayKit

SPEC CHECKSUMS:
  AsyncDisplayKit: 28de788f9d6ec573be7662f0fe8931e656357e93
  PINCache: 6d273a6e0754bd26e3f12a38a90dde73cc6a42b2
  PINRemoteImage: ff63baf185088530db6cfa41cb665e2b5126b5c3

PODFILE CHECKSUM: d1264bf0434b7a26df33e64d1d416cb1d2a8ef90

COCOAPODS: 1.2.0
QiaoDandandeiMac:AsyncDisplayKitCollectionView qiaodandan$ 
 首先，里面有 导入的各个库的版本信息 还有指明的依赖 以及specification（标准规格）checksum 检查说明 
以及 Podfile checksum 唯一的哈希值

所以 总结一下说，podfile里面的东西就是记录了三方库的版本信息 以及依赖的库的版本信息为了实现稳定 或者是不被未知 的更改产生错误，比如说两个并发去pod update 可能最终的库的版本 会跟podfile.lock里面记载的不一样，所以 我觉得之所以叫做podfile.lock 可能增删改的时候 都会上锁 保持唯一写。


3月7日
1、突然想起来一个问题 podfile.lock 存在的意义是什么 有什么作用？
2、AsyncDisplayKit 三方库的使用 实现 原理 View 和 Layer的区别  





3月6日
1、View和Layer的关系：
常见的 UIView 和 CALayer 的关系：
	View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；
	Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。
	UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。

2、比较有意义的一个问题 或者是事情 APP的性能问题，流畅度问题 三方asynchronous 
三方：

AsyncDisplayKit的原理 效果 其中有上段  说道 View 和 Layer的关系








3月2日
锁的应用的举例：
非递归锁 再上锁之后再上锁，就会不能正常使用出错。递归锁 可以 层层递归上锁。
1、代码源码上的例子
类初始化的时候 +initialize，设计到对类的两个字段的更改，对类的 CLS_INITIALIZED 和 CLS_INITIALIZING 的修改，全局的 monitor_t类型的 classInitLock 锁就是用来同步对这两个字段的更改操作。保证其不会死锁。其他的线程都会等这个信号释放，只有这个信号释放了，才能做任何的消息发送，在初始化完成的信号释放之前，这些线程都会被挂起等待资源。

2、业务逻辑上的例子：

2月28日

参考：http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/
结合源码，看项目中的实现原理

陌陌T：
1、关联属性的生命周期问题
什么时候被释放 什么时候被移除
如果是copy的，那么在代码块执行完之后，就会被放入自动释放池中，会被释放掉 指针置为nil。当前所在的分类生命周期要结束的时候 会销毁这个分类的时候，这个分类所关联的 retain策略的属性将会被移除 然后被置为nil，释放。


2、关联对象被存储在什么地方，是不是被存放在被关联对象本身的内存中

不是存放在关联类的本身内存之后，是又开辟了一个内存，好像是一个关联对应表，用来存储关联的属性。




2月20日
小龙猫 陌陌T

1、点击事件的响应
一个是事件的分发 一个是响应链的实现
见博客随笔内容：http://www.cnblogs.com/Jordandan/p/6483835.html
期间 两个重要的方法：
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

 - (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event

响应事件的处理呢？事件的分发，如何调用最终的事件响应方法？？？？这是不是就牵涉到了消息的转发机制？




2、constant * 和 * constant
见demo内容

constant *：const在 * 的左边 是同一种情况 通过指针是不能改变指针所指向的变量的值的
也就是不能通过指针改变指针所指向的变量的值，但是可以通过变量a自己改变变量的值

 * constant：
指针不能变，也就是指针自己的值不能变，也就是指针的指向不能变


3、ARC和MRC的区别，以及ARC怎么实现的，ARC如何知道怎么加retain release？
参考文章：http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=712  对ARC MRC的理解
https://gold.xitu.io/post/584fe4762f301e00573cafc6
第二个关于 自动释放的原理 还没有掌握

ARC（自动引用计数），无需我们自己显式持有（retain）和释放（release）对象，ARC通过对对像加上所有权修饰符（__strong等），编译器通过对象的所有权修饰符将会自动键入引用计数管理（根据所有权修饰符自动键入retain、release、autorelease）

把这段话copy进来是 要学会 如何去规范的表达一个问题的原因和答案 回答要规范正规化 不能太口头 随意。

4、assign 和weak 的区别
assign：用来修饰基本的数据类型，不会置为nil，可能会指向一个不明确的地址空间
weak：用来修饰对象类型，若引用，当对象释放的时候，其属性也会置为nil，是安全的，不会有野指针，也就是不会指针指向一个不明确的地址空间


5、sdwebimage的实现原理

收获：2Gouzi给的建议很中肯：回答要专业一点，不能太口语化，太业余话。





-1.
消息的发送实现：
对一个实例发送消息的时候，会在该实例对应的类的 methodLists中查找
对一个类发送消息的时候，会在该类的MetaClass的methodLists中查找

每一个实例的isa指针，指向自己的class
每一个类的isa指针，指向自己的meta class

消息的转发实现：如何动态的确定消息的发送？？？
[receiver message]
会转换成
msd_send(receiver,selector)
如果receiver不响应message消息，则会去父类查找，父类还不响应，继续去父类查找，如果一直查找到NSObject还不响应，则会进入消息动态处理流程。

消息动态处理流程：








1、[super init]的作用超类完成自己的初始化工作

http://www.jianshu.com/p/9b36e1b636d8
对于self ＝ [super init]的思考：

对象初始化有两种方式：[class new] 与 [[class alloc] init]
［［class alloc］ init］有分配和初始化的过程，alloc 从应用程序的虚拟地址空间上为该对象分配足够的内存，并且将新对象的引用计数加1、将对象的成员变量初始为零，init 会做真正的初使化工作，为对象的实例变量赋予合理有用的值。

[class new]默认调用 alloc与init方法，那么我们无法使用自定义的初始化方法，多了更多的局限性。那么[class alloc] init] 会更方便

为什么这样写？
- (instancetype)init
{
    if (self = [super init]) {
        // Custom initialization
    }
    return self;
}
alloc返回一个有效的未初始化的对象实例。对于self是alloc 返回的指针，同时可以在所有的方法作用域内访问。
但是对于 super，它只是一个 "编译器指示符",告诉编译器在父类中搜索方法的实现。
优先调用[super init] 是为了使超类完成它们自己的初始化工作。
if (self = [super init])
防止父类初始化失败，如果初始化一个对象失败，就会返回nil，当返回nil的时候self = [super init]测试的主体就不会再继续执行。如果不这样做，你可能会操作一个不可用的对象，它的行为是不可预测的，最终可能会导致你的程序崩溃
理解 Self & Super

@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self)
    {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end

self表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。在本例中，无论是[self class]还是[super class]，接受消息者都是Son对象，但super与self不同的是，self调用class方法时，是在子类Son中查找方法，而super调用class方法时，是在父类Father中查找方法。
objc_msgSend（）
objc_msgSendSuper（）

类，父lei，meta class的图？？？？
找到之后补充在这里


引申：
isKindOfClass和isMemberOfClass的区别：
    QDSon * son1 = [[QDSon alloc] init];
    QDSon * son2 = [QDSon new];
    NSLog(@"%@",[son1 class]);
    NSLog(@"%d",[son1 isKindOfClass:[QDSon class]]);//1
    NSLog(@"%d", [son1 isKindOfClass:[QDFather class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDSon class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDFather class]]);//0
    
    //isKindOfClass 判断 认可继承关系 判断是否是本类及子类
    //isMemberOfClass 判断 不认可继承关系 判断是否是本类





2、画圆，画圆角4+1（CC）=5中方式   第一种：使用drawRect方法绘图自定义一个View，在其drawRect方法中操作，尽量避免使用drawRect方法，会耗性能，资源浪费	- (void)drawRect:(CGRect)rect {//一个不透明类型的Quartz 2D绘画环境，相当于一个画布,你可以在上面任意绘画 //获取绘图上下文       CGContextRef context = UIGraphicsGetCurrentContext();设置各种字体颜色 格式最后用CGContextDrawPath方法，画在画布上   CGContextDrawImage画图片} 第二种：设置secondView.layer.cornerRadius = 50;    secondView.layer.masksToBounds = YES;     会引起离屏渲染第三种：使用贝塞尔曲线UIBezierPath和Core Graphics框架在图片的绘图上下文中画出一个透明的圆。增加CPU负担，增加内存开销    UIImageView *imageViewTwo = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageViewTwo.image = [UIImage imageNamed:@"imageName1.jpg"];    //开始对imageView进行画图，在透明的这个imageView的画布上开始画    UIGraphicsBeginImageContextWithOptions(imageViewTwo.bounds.size, NO, [UIScreen mainScreen].scale);//    UIGraphicsBeginImageContextWithOptions(<#CGSize size#>, <#BOOL opaque#>, <#CGFloat scale#>)    //opaque：不透明    //使用贝塞尔曲线画出一个圆形图，并且切掉其他的，就剩下了透明的想要的那个圆    [[UIBezierPath bezierPathWithRoundedRect:imageViewTwo.bounds cornerRadius:imageViewTwo.frame.size.width] addClip];//    + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;     //rounds all corners with the same horizontal and vertical radius    [imageViewTwo drawRect:imageViewTwo.bounds];        imageViewTwo.image = UIGraphicsGetImageFromCurrentImageContext();    //结束画图    UIGraphicsEndImageContext();    [self.view addSubview:imageViewTwo];          第四种：使用CAShapeLayer和UIBezierPath设置圆角，设置view.layer.mask同样会触发离屏渲染。    UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageView.image = [UIImage imageNamed:@"imageName1.jpg"];        UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];        CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init];    //设置大小    maskLayer.frame = imageView.bounds;    //设置图形样子    maskLayer.path = maskPath.CGPath;    imageView.layer.mask = maskLayer;        [self.view addSubview:imageView];第五种：CC的方法，addsubLayerUIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 80, 80)];            [imageView setImage:[UIImage imageNamed:@"AppIcon60x60"]];            CAShapeLayer * layer = [CAShapeLayer layer];            UIBezierPath * path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 80, 80)];            UIBezierPath * circlePath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 80, 80)];            [path appendPath:circlePath];            [path setUsesEvenOddFillRule:YES];            [path addClip];            layer.path = path.CGPath;//            layer.fillColor = [UIColor whiteColor].CGColor;//改成跟北京色一致的            layer.fillColor = [UIColor colorWithRed:240/255.f green:240/255.f blue:240/255.f alpha:1].CGColor;            layer.fillRule = kCAFillRuleEvenOdd;            [imageView.layer addSublayer:layer];            [cell.contentView addSubview:imageView]; 第六种：混合两个imageView，遮盖下面的那个，形成圆角需要切图配合，更直接的，就直接让切图给一个圆角图就可以了。总结：尽量避免重写 drawRect 方法。不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 * 1134 * 4 字节 ≈ 3.4 Mb 的内存。在 内存恶鬼drawRect 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。最基础的一种UIView.layer.cornerRadiusmaskToBounse =yes设置 masksToBounds 会导致离屏渲染，出现性能降低 label 的四周出现了黄色的标记，说明这里出现了离屏渲染高效设置圆角为普通的 UIView设置圆角，和为 UIImageView 设置圆角的原理截然不同。有什么不同？离屏渲染：指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。3、tabBar左右滑动的问题再由tabBar的页面左右，左右滑动的时候，有时候，tabbar不能跟着页面滑动？
4、tableView加timer    什么情况下，timer不能正常的释放掉，什么可以使timer正常的释放掉。见YYFPSLabel的实现。
常见会有bug，tableview滚动会影响timer，tableview滚动的时候，咱阻塞timer，这说明timer添加到的RunLoop的mode不对，需要提高model的优先级，
有三个mode：
NSDefaultRunLoopMode - 标准优先级
NSRunLoopCommonModes -这种解决方式是将 Timer 加入到顶层的 RunLoop 的 "commonModeItems" 中。"commonModeItems" 被 RunLoop 自动更新到所有具有"Common"属性的 Mode 里去。
UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
5、客户详情的右上角的聚合按钮6、keyWindow的问题见仿写iOS系统的浮动聚合按钮的demo？？8、mjrefresh实现9、ASI   AFN10、srwebsocket  内部实现   保活机制12、界面等比放大13、ARC 下 viewdidload 中定义的变量什么时候会释放14、数据库升级
15、uicontrol   uiresponse16、block  为啥不能修改局部变量17、内存管理  strong weak18、自动释放池  三个，加到哪一个19、KVC   KVO21、static  22、http  和  https23、iOS目录结构24、framework   .a   静态库和动态库25、socket26、bitcode27、死锁产生的条件，怎么避免
四个必要条件：
1、互斥条件    
2、请求与保持   
3、不剥夺条件    
4、循环等待条件28、TCP和UDP

tcp协议和udp协议的差别 

             TCP           UDP 
是否连接      面向连接         面向非连接 
传输可靠性    可靠            不可靠 
应用场合      传输大量数据      少量数据 
速度         慢              快



TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ 
  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。 




网络的5层分层模型：
物理层，数据链路层，网络层，运输层，应用层

TCP/IP协议在分别是什么层的协议？
UDP层是什么层的协议，数据报

滑动窗口协议是哪个层的协议？





29、userdefault  存储的数据能通过物理路径找到吗31、深入理解RunLoop32、深入理解GCD
见GCDNotes.txt里面包括了1和2

3：dispatch source
4：dispatch queue挂起和dispatch queue目标锁定和信号量 




33、定时帧NSTimer和CADisplayLink
见博客http://www.cnblogs.com/Jordandan/p/6197273.html
定时帧




30、获取帧率见YYFPSLabel的实现，博客的记录





31、block中修改变量的问题

 block 的目的是为了支持并行编程，对于普通的 local 变量，我们就不能在 block 里面随意修改
（原因很简单，block 可以被多个线程并行运行，会有问题的）
   而且如果你在 block 中修改普通的 local 变量，编译器也会报错。那么该如何修改外部变量呢？
有两种办法，
第一种是可以修改 static变量把变量变成 全局变量；
第二种是可以修改用新关键字 __block 修饰的变量。

请看：
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    
    __block int blockLocal  = 100;
    static int staticLocal  = 100;
    
    void (^aBlock)(void) = ^(void){ 
        NSLog(@" >> Sum: %d\n", global + staticLocal);
        
        global++;
        blockLocal++;
        staticLocal++;
    };
    
    aBlock();

    NSLog(@"After modified, global: %d, block local: %d, static local: %d\n", global, blockLocal, staticLocal);

    [pool release];

执行之后，值均为：101





32、
for 
for-in：快速枚举，对于可变数组进行枚举操作时，不能通过添加或删除对象等这类操作来改变数组容器,否则就会报错.而本身这种操作也是有问题的，数组容器已经改变，可能遍历到没有分配的位置，用for循环机器不能自己察觉，但是枚举器可以察觉。

EnumerateObjectsUsingBlock
enumerateKeysAndObjectsUsingBlock
enumerateObjectsWithOptions

1.
enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }

2.
enumerateObjectsWithOptions:<#(NSEnumerationOptions)#> usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }

3.
enumerateObjectsAtIndexes:<#(nonnull NSIndexSet *)#> options:<#(NSEnumerationOptions)#> usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }




33、instrument的使用
Timer Profiler时间分析器
Allocations 内存分配使用情况
内存泄露僵尸对象
循环引用
FPS
离屏渲染
CoreAnimation动画执行





34、内存划分五大区：
1、代码区
1、全局区，静态区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的静态变量和未初始化的动态变量是在相邻的区域的，程序结束后系统释放。
3、常量区：常量字符串就是放在这里
4、栈：一般由编译器操作，会存放一些局部变量，等。
5、堆：一般由程序员管理，比如alloc申请内存，一般的对象都在堆区。（链表

35、
strong：
weak：

weak和strong不同的是：当一个对象不再有strong类型的指针指向它的时候 它会被释放  ，即使还有weak型指针指向它。
一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。

可能有个例子形容是妥当的。

想象我们的对象是一条狗，狗想要跑掉（被释放）。

strong型指针就像是栓住的狗。只要你用牵绳挂住狗，狗就不会跑掉。如果有5个人牵着一条狗（5个strong型指针指向1个对象），除非5个牵绳都脱落 ，否着狗是不会跑掉的。

weak型指针就像是一个小孩指着狗喊到：“看！一只狗在那” 只要狗一直被栓着，小孩就能看到狗，（weak指针）会一直指向它。只要狗的牵绳脱落，狗就会跑掉，不管有多少小孩在看着它。

只要最后一个strong型指针不再指向对象，那么对象就会被释放，同时所有的weak型指针都将会被清除。



copy：建立一个索引计数为1的对象，然后释放旧对象。对NSString。对NSString 


retain：释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 。对其他NSObject和其子类 


copy和retain的区别：

copy其实是建立了一个相同的对象，而retain不是；

copy是内容拷贝，retain是指针拷贝；

copy是内容的拷贝 ,对于像NSString,的确是这样，但是如果拷贝的是NSArray这时只是copy了指向array中相对应元素的指针.这便是所谓的"浅复制"。



assign： 简单赋值，不更改索引计数（Reference Counting）。对基础数据类型 （NSInteger，CGFloat）和C数据类型（int, float, double, char, 等等）
unsafe_unretain：
autoreleaseing：



__block和__weak修饰符的区别：

__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。

__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。

__block对象可以在block中被重新赋值，__weak不可以。


36、分类和扩展：
扩展是无名分类，
扩展里面的属性，是私有的，子类也访问不了。
能为某个类附加额外的属性，成员变量，方法声明
一般的类扩展写到.m文件中
一般的私有属性写到类扩展


分类可以通过关联实现属性
分类只能扩充方法，不能扩展属性和成员变量（如果包含成员变量会直接报错）。
如果分类中声明了一个属性，那么分类只会生成这个属性的set、get方法声明，也就是不会有实现。
但是扩展不可以？？？不可以什么？？？不可以生成属性的set get方法,不可以添加属性和成员变量

37、Charles实现对Https进行抓包，使用的原理就是中间人技术（man-in-the-middle）中间人技术（man-in-the-middle）：

38、
NSURLSession总结：

1、分有普通、上传和下载 三种不同的网络请求任务：
NSURLSessionDataTask, NSURLSessionUploadTask和NSURLSessionDownloadTask
2、创建的task都是挂起状态，需要resume才能执行。
3、NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。

实例化网络下载任务时将下载的文件保存到沙盒的caches文件夹中：

[NSURLSessionDownloadTask [NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@"http://127.0.0.1/dawenjian.zip"] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
   //获取沙盒的caches路径
   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]stringByAppendingPathComponent:@"kkk.dmg"];
   //生成URL路径
   NSURL *DCurl = [NSURL fileURLWithPath:path];
   //将文件保存到沙盒指定文件目录下
   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   }]resume];

4、NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。

5、NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 
[ [self.session downloadTaskWithResumeData:self.resumeData]resume]方法进行继续下载操作。   

6、
NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。

NSURLSession可以设置三种配置信息，分别通过调用三个累方法返回配置对象：

+ (NSURLSessionConfiguration *)defaultSessionConfiguration
配置信息使用基于硬盘的持久话Cache，保存用户的证书到钥匙串,使用共享cookie存储；
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration 
配置信息和default大致相同。除了，不会把cache，证书，或者任何和Session相关的数据存储到硬盘，而是存储在内存中，生命周期和Session一致。比如浏览器无痕浏览等功能就可以基于这个来做；
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier
配置信息可以创建一个可以在后台甚至APP已经关闭的时候仍然在传输数据的session。
注意，后台Session一定要在创建的时候赋予一个唯一的identifier，这样在APP下次运行的时候，能够根据identifier来进行相关的区分。如果用户关闭了APP,IOS 系统会关闭所有的background Session。而且，被用户强制关闭了以后，IOS系统不会主动唤醒APP，只有用户下次启动了APP，数据传输才会继续。

39、断点续传


40、各种锁汇总：

1、NSLock
遵循NSLocking协议

lock消息
unlock消息

连续锁两次会死锁，不能正常，多次的要用递归锁

2、NSRecursiveLock
可以被一个线程多次获得，而不会引起死锁
故名思议，是在递归中用的，不会引起死锁失效

3、NSCondition
算是同步锁
可以实现不同线程的调度
一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。
发送信号之后，解锁开锁。

4、NSConditionLock
NSConditionLock 对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁。
和 NSCondition 很像，但实现方式是不同的。
两个线程需要特定顺序执行的时候，例如生产者消费者模型，则可以使用 NSConditionLock 。当生产者执行执行的时候，消费者可以通过特定的条件获得锁，当生产者完成执行的时候，它将解锁该锁，然后把锁的条件设置成唤醒消费者线程的条件。锁定和解锁的调用可以随意组合，lock 和 unlockWithCondition: 配合使用 lockWhenCondition: 和 unlock 配合使用。

- (void)producer {
    while (YES) {
        [self.conditionLock lock];
        NSLog(@"have something");
        self.count++;
        [self.conditionLock unlockWithCondition:1];
    }
}

- (void)consumer {
    while (YES) {
        [self.conditionLock lockWhenCondition:1];
        NSLog(@"use something");
        self.count--;
        [self.conditionLock unlockWithCondition:0];
    }
}

5、pthread_mutex
互斥锁是一种超级易用的互斥锁，使用的时候，只需要初始化一个 pthread_mutex_t 用 pthread_mutex_lock 来锁定 pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。

6、pthread_rwlock

读写锁，在对文件进行操作的时候，写操作是排他的，一旦有多个线程对同一个文件进行写操作，后果不可估量，但读是可以的，多个线程读取时没有问题的。

当读写锁被一个线程以读模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程还可以继续进行。
当读写锁被一个线程以写模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程也被阻塞。

7、POSIX Conditions
POSIX 条件锁需要互斥锁和条件两项来实现，虽然看起来没什么关系，但在运行时中，互斥锁将会与条件结合起来。线程将被一个互斥和条件结合的信号来唤醒。

首先初始化条件和互斥锁，当 ready_to_go 为 flase 的时候，进入循环，然后线程将会被挂起，直到另一个线程将 ready_to_go 设置为 true 的时候，并且发送信号的时候，该线程会才被唤醒。

8、OSSpinLock
自旋锁，和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。
YY大神有

9、os_unfair_lock
iOS 10新出的解决自选锁失效的问题

10、dispatch_semaphore
信号量机制实现锁，等待信号，和发送信号，正如前边所说的看门人一样，当有多个线程进行访问的时候，只要有一个获得了信号，其他线程的就必须等待该信号释放。

11、@synchronized
一个便捷的创建互斥锁的方式，它做了其他互斥锁所做的所有的事情。


应当针对不同的操作使用不同的锁：

1、当进行文件读写的时候，使用 pthread_rwlock 较好，文件读写通常会消耗大量资源，而使用互斥锁同时读文件的时候会阻塞其他读文件线程，而 pthread_rwlock 不会。

2、当性能要求较高时候，可以使用 pthread_mutex 或者 dispath_semaphore，由于 OSSpinLock 不能很好的保证线程安全，而在只有在 iOS10 中才有 os_unfair_lock ，所以，前两个是比较好的选择。既可以保证速度，又可以保证线程安全。

3、对于 NSLock 及其子类，速度来说 NSLock < NSCondition < NSRecursiveLock < NSConditionLock 。


41、生产者消费者

42、NSCoreData

43、其他的本地化

44、
C语言的问题

45、数据结构的问题
链表，矩阵

46、swift的小demo

48、哈希碰撞解决方法：
1、线性的，往后推到下一个空的位置
2、非线性的，再一次哈希
3、链地址，在这个位置放置一个链表，放置哈西之后存在该位置的元素
4、建立一个公共溢出区，放置这些，这个没有印象啦


47、SDwebimage的源码复习

SDWebImageManager
SDWebImageDownloader


SD失效的问题可能解决方案：

1、有可能是图片的url地址不对，有可能浏览器可以打开，但是这个地址浏览器是做了处理的，所以浏览器能打开。

2、如果图片地址是Http，那么就需要关闭ATS。

ATS (App Transport Security)

新特性要求App内访问的网络必须使用HTTPS协议，

我们这里只是说明一下如何关闭该特性,让其可以访问http开头的网址.

关闭很简单,打开项目中的info.plist文件,在其中添加一个字典类型的项目App Transport Security Settings,然后在其中添加一个key:Allow Arbitrary Loads,其值为YES,


- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 

有全能初始化方法（designated initializer）的概念，这个方法也就相当于是全能操作方法，所有的方法最后都会调用这个方法，都会集中到这个方法中执行

1、方法中先进行了一个关联
static char imageURLKey;
将传过来的url 设置成imageURLKey的value，由于imageURLKey是指向char类型的一个指针，所以是& imageURLKey，value是url。

2、placeholder有的话，先设置上placeholder图片

3、然后对非空的url进行图片的请求，交给了单例的SDWebImageManager，还有相应的SDWebImageOperation协议，以及相应的协议方法

id <SDWebImageOperation> operation 
协议中有唯一的
- (void)cancel;
方法

SDWebImageManager
中的方法
- (id <SDWebImageOperation>)downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock {

里面还有一个self.failedURLs数组，所有的失败的url都会放里面，这个数组作为公共资源，需要考虑线程安全，所以用 @synchronized (self.failedURLs) {进行了加锁操作来访问和修改，这是对数据请求进行的优化，对于失败的url的数据请求进项了改进，不会一直请求失败的url占用资源。

5、然后对于正常的数据请求：

添加进入 runningOperations 之中。

还有一个重要的类SDWebImageCombinedOperation

@property (strong, nonatomic) NSOperation *cacheOperation;

cacheOperation是NSOperation




designate 
 | BrE ˈdɛzɪɡnət, AmE ˈdɛzɪɡnət, ˈdɛzɪɡˌneɪt |
formal (appointed)受委派而尚未上任的 shòu wěipài ér shàngwèi shàngrèn de (elected)已当选而尚未就职的 yǐ dāngxuǎn ér shàngwèi jiùzhí de
prime minister designate
新当选而尚未上任的首相


http://www.jianshu.com/p/4191017c8b39
SD总结：
SDWebImageAllowInvalidSSLCertificates 允许使用无效的SSL证书，主要用于测试目的，在正式环境中慎用
SDWebImageHighPriority 优先下载
SDWebImageDelayPlaceholder 等待下载完成后再显示占位图片，延迟显示占位图片
SDWebImageTransformAnimatedImage 改变动画形象
SDWebImageAvoidAutoSetImage 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上

options 枚举：

1、SDWebImageRetryFailed 失败后重试， 默认如果下载失败,这个url会被加入黑名单并且不会尝试再次下载,设置这个枚举会阻止把失败的url加入黑名单，不断尝试重新下载

2、SDWebImageLowPriority 延迟下载， 默认情况下,图片会在交互发生的时候下载(例如你滑动tableview的时候),这个枚举会禁止这个特性,导致的结果就是在scrollview减速的时候才会开始下载(也就是你滑动的时候scrollview不下载,你手从屏幕上移走,scrollview开始减速的时候才会开始下载图片)

3、SDWebImageCacheMemoryOnly 只在内存缓存

4、SDWebImageProgressiveDownload 渐进式下载,显示的图像是逐步在下载

很重要
5、SDWebImageRefreshCached 刷新缓存，有时本地图片更新后与服务器没有同步一致时可以使用（例如更新头像），专门处理相同url，但不同image的情况的
原因：默认情况下，SDWebImage会忽略Header中的缓存设置，将图片以url为key进行保存，url与图片是一一对应关系。所以请求同一个url时，SDWebImage会从缓存中取得图片。一般的情况下用此方法可以满足我们的应用要求，但是如果你请求同一个url，而这张图片在服务器端更新了，本地客户端再次请求时还是会返回缓存中的旧图片，例如加载头像类经常更新的图片时，就会出现头像不能更新的问题，由于url与图片一一对应，一种解决的办法是改变部分url地址方式实现更新，不过这种方法操作起来很复杂， 另一种将第三个参数设置为SDWebImageRefreshCached就可以实现图片更新操作了。



6、SDWebImageContinueInBackground 启动后台下载，app进入后台后继续下载

7、SDWebImageHandleCookies 处理存储在NSHTTPCookieStore中的cookie
NSMutableURLRequest.HTTPShouldHandleCookies = YES;

8、SDWebImageAllowInvalidSSLCertificates 允许使用无效的SSL证书，主要用于测试目的，在正式环境中慎用

9、SDWebImageHighPriority 优先下载

10、SDWebImageDelayPlaceholder 等待下载完成后再显示占位图片，延迟显示占位图片

11、SDWebImageTransformAnimatedImage 改变动画形象

12、SDWebImageAvoidAutoSetImage 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上


48、https

2017年1月24日—————————————————————————

49、遇到的一个问题的结局：
https验证证书的问题
问题描述：web页面有一个动态gif的表情一直不能成功显示出来，

<img src=“https://img2.soufun.com/bbsv2/face/em016.gif”>

用NSUrlSession请求之后，错误信息是这个：

Error Domain=NSURLErrorDomain Code=-1202 "此服务器的证书无效。您可能正在连接到一个伪装成“img2.soufun.com”的服务器，这会威胁到您的机密信息的安全。" UserInfo={NSURLErrorFailingURLPeerTrustErrorKey=<SecTrustRef: 0x608000116020>, NSLocalizedRecoverySuggestion=您仍要连接此服务器吗？, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9843, NSErrorPeerCertificateChainKey=(
    "<cert(0x7ffbba8ec000) s: *.cdn.myqcloud.com i: Symantec Class 3 Secure Server CA - G4>",
    "<cert(0x7ffbba8cc000) s: Symantec Class 3 Secure Server CA - G4 i: VeriSign Class 3 Public Primary Certification Authority - G5>",
    "<cert(0x7ffbba8eca00) s: VeriSign Class 3 Public Primary Certification Authority - G5 i: Class 3 Public Primary Certification Authority>",
    "<cert(0x7ffbba8cc800) s: Class 3 Public Primary Certification Authority i: Class 3 Public Primary Certification Authority>"
), NSUnderlyingError=0x61800024c900 {Error Domain=kCFErrorDomainCFNetwork Code=-1202 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, kCFStreamPropertySSLPeerTrust=<SecTrustRef: 0x608000116020>, _kCFNetworkCFStreamSSLErrorOriginalValue=-9843, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9843, kCFStreamPropertySSLPeerCertificates=(
    "<cert(0x7ffbba8ec000) s: *.cdn.myqcloud.com i: Symantec Class 3 Secure Server CA - G4>",
    "<cert(0x7ffbba8cc000) s: Symantec Class 3 Secure Server CA - G4 i: VeriSign Class 3 Public Primary Certification Authority - G5>",
    "<cert(0x7ffbba8eca00) s: VeriSign Class 3 Public Primary Certification Authority - G5 i: Class 3 Public Primary Certification Authority>",
    "<cert(0x7ffbba8cc800) s: Class 3 Public Primary Certification Authority i: Class 3 Public Primary Certification Authority>"
)}}, NSLocalizedDescription=此服务器的证书无效。您可能正在连接到一个伪装成“img2.soufun.com”的服务器，这会威胁到您的机密信息的安全。, NSErrorFailingURLKey=https://img2.soufun.com/bbsv2/face/em016.gif, NSErrorFailingURLStringKey=https://img2.soufun.com/bbsv2/face/em016.gif, NSErrorClientCertificateStateKey=0}

是https客户端需要验证这个域名的自签名证书的问题，

后查实，项目中的图片的域名需要进行收敛操作，只有将域名进行收敛操作之后，相应的域名的站点才有相应的证书，收敛表情上传之前的表情的url即可。相应的域名受凉犯法也根据需求扩充了一下。

还有我新加入的头像也显示不正常，猜测也是这个问题。


3、用户头像不能显示的问题：

web页中的url
http://img8.soufunimg.com/viewimage/zxb/2015_11/12/m05/01/c8/wkgeqlzemjmibv3qaaqajiha7kyaajzrandul4abbqk579/156x156c.jpg"

http://img8.soufunimg.com/viewimage/zxb/2015_11/12/M05/01/C8/wKgEQlZEMjmIbv3qAAQajIhA7kYAAJzRANDUL4ABBqk579/156x156c.jpg


img src的路径就有问题
虽然域名协议不区分大小写
但是路径可能区分大小写
所以 一模一样的url img 的src 是小写的
访问不到这个图片
我的 url是大小写区分的 可以访问到
所以 这个图片本身就访问不到 现在做收敛了也找不到
只能这个图片能访问到了 才能做收敛


1月23日 MT有关问题总结：

问题总结，
1、有关推送的
2、有关weak原理的
3、加分隔符的
4、快排实现
5、load 和 initlizer
6、swizzling
7、实现能力
8、一个view上面添加了按钮，按钮在view的边缘，有什么问题 1月24日想起扩充
9、响应链的问题，button超出父控件的问题
10、jsonModel的实现原理
11、UIView和layer的关系



自己太大意了，最基础的都没有做好，希望自己认识自己，改正不足的地方。
感谢MT，感谢我的朋友。感谢一直陪伴我的CC，我会努力的。


