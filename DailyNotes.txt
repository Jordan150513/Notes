每天一个问题

3月14日

添加了观察者 但是没有出发观察者的方法，为什么会这样的？原因是啥？

参考网上大神总结的问题 我搬到这里学习
问题：
1、[※]@property中有哪些属性关键字？
	noatomic weak strong copy assign 

2、[※]weak属性需要在dealloc中置nil么？
	不需要, weak属性，在对象销毁的时候，weak属性会置为nil

3、[※※]@synthesize和@dynamic分别有什么作用？
	synthesize 指明属性对应的实例变量的名字 合成属性的实例变量
	@dynamic 在编译器自动给属性添加 set get方法。
	对不对？

4、[※※※]ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些？
	没有指定 默认是atomic 默认的是strong 还是weak？？

5、[※※※]用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题？
	如果使用Strong，可能会有两个影响，一个是
	Mutable是其子类，如果是赋值给了一个Mutabel的子类，子类不能进行相应的操作方法。

6、[※※※]@synthesize合成实例变量的规则是什么？假如property名为foo，存在一个名为_foo的实例变量，那么还会自动合成新变量么？
	不会吧？不确定 @synthesize 合成实例变量的规则

7、[※※※※※]在有了自动合成属性实例变量之后，@synthesize还有哪些使用场景？
	同步锁？

8、[※※]objc中向一个nil对象发送消息将会发生什么？
	是安全的不会崩溃

9、[※※※]objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系？
	[obj foo]的本质是调用了objc_msgSend(obj，foo)

10、[※※※]什么时候会报unrecognized selector的异常？
	给一个对象发送消息，在该对象的方法表中（如果是实例方法，就在其类的方法表中找不到对应的方法，如果是类方法，就在元类的方法表中查找）找不到对应的消息。 牵涉到消息的转发机制。这里还不是很熟悉。

11、[※※※※]一个objc对象如何进行内存布局？（考虑有父类的情况）
	这个确实不知道，

12、[※※※※]一个objc对象的isa的指针指向什么？有什么作用？
	实例对象的isa指向它的类，类对象的isa指向其元类

13、[※※※※]下面的代码输出什么？

@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self) {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end
	输出：
	TestDemo[541:332834] Son
	TestDemo[541:332834] Son
	这个应该怎么解释调用过程呢？？？

14、[※※※※]runtime如何通过selector找到对应的IMP地址？（分别考虑类方法和实例方法）
	类方法：
	会通过类的isa指针到类的元类中的方法表(method_list中进行)查找，在method_list中存储的方法结构体中有IMP指针

	实例方法：
	会通过selector到实例对象isa指向的类方法表（method_list）中寻找对应的方法，映射对 key-value 找到对应的方法结构体重有IMP指针

	这个需要到源码中找到相应的源码

15、[※※※※]使用runtime Associate方法关联的对象，需要在主对象dealloc的时候释放么？
	不需要，会在对象销毁的时候，会移除关联的对象，就被释放掉了。

16、[※※※※※]objc中的类方法和实例方法有什么本质区别和联系？
	类方法存储在元类中的方法列表里，通过类的isa到元类的方法列表里取查找
	实例方法存储在类的方法列表里，通过实例的isa到类的方法列表里去查找

17、[※※※※※]_objc_msgForward函数是做什么的，直接调用它将会发生什么？
	消息转发，当前对象的方法列表里，没有对应的方法（发送的消息），就会调用。。。。后面就又不清楚了。不仅要清楚实现过程，还需要清楚源码的实现。

18、[※※※※※]runtime如何实现weak变量的自动置nil？
	那个方法叫什么来这 weak_clean_nolock（）

19、[※※※※※]能否向编译后得到的类中增加实例变量？能否向运行时创建的类中添加实例变量？为什么？
	不能向编译后得到的类中增加实例变量，但是可以向运行的类中，动态的增加属性，但是增加不了实例变量。

20、[※※※]runloop和线程有什么关系？
	一一对应的关系

21、[※※※]runloop的mode作用是什么？
	
22、[※※※※]以+ scheduledTimerWithTimeInterval...的方式触发的timer，在滑动页面上的列表时，timer会暂定回调，为什么？如何解决？
	Time加入的mode 优先级太低了，将这个timer加入到一个commonmode中

23、[※※※※※]猜想runloop内部是如何实现的？
	就老老实实 按照大牛写的说 但是具体说，还需要总结 整理一下

24、[※]objc使用什么机制管理对象内存？
	自动引用计数 ARC

25、[※※※※]ARC通过什么方式帮助开发者管理内存？
	引用计数，谁创建 谁管理，谁负责释放，强引用的时候引用计数retain，+1，不需要的时候release引用计数-1，引用计数为0 的时候 回收对象内存。

26、[※※※※]不手动指定autoreleasepool的前提下，一个autorealese对象在什么时刻释放？（比如在一个vc的viewDidLoad中创建）
	释放池drain的时候释放

27、[※※※※]BAD_ACCESS在什么情况下出现？
	野指针 数组越界

28、[※※※※※]苹果是如何实现autoreleasepool的？
	autoreleasepoolpage，将需要autoreleasepool的加入到autoreleasepoolPage中，然后压入栈。这个还不确定

29、[※※]使用block时什么情况会发生引用循环，如何解决？
	self强引用block block中又强引用self，就会发生引用循环
	需要在block中更改的对象，需要经过__block,或者weak，转换成弱引用，避免引用循环。

30、[※※]在block内如何修改block外部变量？
	添加__block修饰该外部变量

31、[※※※]使用系统的某些block api（如UIView的block版本写动画时），是否也考虑引用循环问题？
	不需要吧？这个不确定。
32、[※※]GCD的队列（dispatch_queue_t）分哪两种类型？
	dispatch_global_queue 和 dispatch_main_queue

33、[※※※※]如何用GCD同步若干个异步调用？（如根据若干个url异步加载多张图片，然后在都下载完成后合成一张整图）
	用dispatch_group,会等grou执行完之后，再执行后面的。

34、[※※※※]dispatch_barrier_async的作用是什么？
	栅栏 栅栏要等栅栏前面的执行完了才执行栅栏，栅栏里面完全执行完了，再执行栅栏后面的，栅栏里面可同步 可异步，这个是异步执行栅栏里面的。

35、[※※※※※]苹果为什么要废弃dispatch_get_current_queue？

36、[※※※※※]以下代码运行结果如何？
- (void)viewDidLoad
{
    [super viewDidLoad];
    NSLog(@"1");
    dispatch_sync(dispatch_get_main_queue(), ^{
        NSLog(@"2");
    });
    NSLog(@"3");
}
我亲测运行报错了，这是为啥？？？


37、[※※]addObserver:forKeyPath:options:context:各个参数的作用分别是什么，observer中需要实现哪个方法才能获得KVO回调？
   addObserver:<#(nonnull NSObject *)#> forKeyPath:<#(nonnull NSString *)#> options:<#(NSKeyValueObservingOptions)#> context:<#(nullable void *)#>]
    第一个参数：指明是给谁添加观察者
    第二个参数： <#(nonnull NSString *)#> 指明keypath
    第三个参数：NSKeyValueObservingOptions 有三个枚举值 initial new old
    第四个参数： <#(nullable void *)#> context
    context:需要传递的对象是一个(void *)类型的数据，这是一个C类型的对象，我们需要做的就是将id类型的对象转成C类型。
观察者模式：


38、[※※※]如何手动触发一个value的KVO

39、[※※※]若一个类有实例变量NSString *_foo，调用setValue:forKey:时，可以以foo还是_foo作为key？

40、[※※※※]KVC的keyPath中的集合运算符如何使用？

41、[※※※※]KVC和KVO的keyPath一定是属性么？

42、[※※※※※]如何关闭默认的KVO的默认实现，并进入自定义的KVO实现？

43、[※※※※※]apple用什么方式实现对一个对象的KVO？

44、[※※]IBOutlet连出来的视图属性为什么可以被设置成weak?

45、[※※※※※]IB中User Defined Runtime Attributes如何使用？

46、[※※※]如何调试BAD_ACCESS错误

47、[※※※]lldb（gdb）常用的调试命令？
	watch point、 p、 po、


1、objc中向nil发送消息，是安全的 不会崩溃。

3月13日
LH DD 题：
1、通知中心的原理
2、算法121abccba找出字符串中最长的回文数
3、犯人喝毒酒逻辑题
4、网络请求缓存设计web
5、为什么category可以添加方法不能添加成员变量
6、热更新替代方案一 不是苹果不让用了么？
7、autoreleasepool的使用场景
8、sel和imp的区别
9、http多次请求会建立几个tcp连接
10、meta class是什么 它的作用是什么？
11、imageNamed：对象什么时候释放
12、super.class打印
13、main函数之前 程序做了什么
14、如何设定一个指定线程数目的线程池


BD T：
1、流量监控怎么做？
2、动画
3、基础和原理


3月13日
1、代码规范的问题：

a. 注意 不要将驼峰命名法和下划线命名法 混合使用 要规范使用
b.如果方法表示让对象执行一个动作，使用动词打头来命名，注意不要使用 do，does 这种多余的关键字，动词本身的暗示就足够了。
c.方法中不要用 with 来连接两个参数: withAge: 应当换为age:
d.初始化方法的 全能初始化方法的 规范，所有的初始化方法最终都是通过调用全能初始化方法实现的。其他的初始化方法的参数是全能初始化方法的子集。
e.枚举的定义 建议使用 NS_ENUM 和 NS_OPTIONS 宏来定义枚举类型，例如：
//定义一个枚举 枚举的名字是 CYLSex 执行枚举的类型是 NSInteger
typedef NS_ENUM(NSInteger, CYLSex) {
    CYLSexMan,
    CYLSexWoman
};
f.要用NSInter 而不是int 用CGFloat 而不是float，要用NSFoundation框架的东西，不要直接使用。
g.拒绝中英文混合使用
h.不管是MVC 还是MVVP 。业务逻辑放在业务逻辑应该的地方，比如说控制器里面，不要放在对象类中，比如说，不要把登陆实现方法写在model
中。


先总结这么多 ，以后再慢慢加




3月10日
带着问题去学习，感觉会效率更加好一些
加油 
根据这个 带着这个去学习：
http://blog.sunnyxx.com/2015/07/04/ios-interview/

1、@property 后面可以有哪些修饰符？
	noatomic/atomic strong/weak/assign/copy 指定setter getter 

2、什么情况使用 weak 关键字，相比 assign 有什么不同？
	特点：weak和assign 既不保留新值，也不释放旧值,
	什么情况下使用weak关键字：在为了避免循环引用的地方，使用weak，可以避免循环引用，比如说delegate。
  	weak 关键字 非拥有关系 用来修饰NSObject对象 assign针对的是基本数据类型 NSInter Float等
assign修饰的基本数据类型对象，在释放之后，并不会置为nil，但是基本数据类型是在栈中分配的存储空间，栈的空间管理，是由系统自行处理，释放或者分配，不会造成野指针。不会崩溃。weak修饰的对象是在堆上申请的，对象释放的时候，会被置为nil。如果没有被置为nil就是一个野指针，还指向堆中的某个地方，当下次用到堆中这个地址的时候，就会崩溃了，weak 在对象被释放之后，会置为nil，是安全的，不会造成野指针。不会引起崩溃。

3、怎么用 copy 关键字？
	是用来修饰NSString类型的 会使引用计数加1，
Strong会使两个指针 指向同一个地址
copy会在内存里拷贝一份数据 两个指针 指向不同的地址
NSString用copy，经常用copy的特质来保护其封装性，NSString NSDictionary NSArray经常使用copy来修饰属性，是因为他们有对应的Mutable类型，为了确保来赋值的时候，有可能是赋给子类mutable，所以为了防止发生意外的改变内容，拷贝一份不可变的字符串，确保字符串中的值不会在对象不知道的情况下 进行更改，也就是在set的时候进行了更改。

在 MRC 中,方法内部的 block 是在栈区的,使用 copy 可以把它放到堆区.在 ARC 中写不写都行。


4、这个写法会出什么问题： @property (copy) NSMutableArray *array;
	将NSMutableArray 声明成了copy修饰的特性的 类的实例 对NSMutableArray 类型的array 不是拥有的关系。
是又拷贝了一份 又用一个指针指向现在拷贝的这一份拷贝，拷贝的这一份是NSArrya，就会出现 之前那个指针指向的再去操作 就会被释放了 或者 数据不一致？？这个回答可以吗？准确不？不对 要说到 copy的是一个不可变的NSarray，所以，是不能记性操作的。

两个问题：
1、添加,删除,修改数组内的元素的时候,程序会因为找不到对应的方法而崩溃.因为 copy 就是复制一个不可变 NSArray 的对象；
2、使用了 atomic 属性会严重影响性能 ；
如果某属性不具备 nonatomic 特质，那它就是“原子的”(atomic)
.h
@property (nonatomic, copy) NSMutableArray *mutableArray;

.m
NSMutableArray *array = [NSMutableArray arrayWithObjects:@1,@2,nil];
self.mutableArray = array;   //这里set方法，是copy了一个不可变的NSArray,所以接下来进行操作的时候，就会崩溃。
[self.mutableArray removeObjectAtIndex:0];


 
5、如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
	copy修饰的属性的setter方法的实现 MRC的实现方式？??
	@property（atomic,copy）NSString * stringC;
	-(void)setStringC:(NSString *)string{
	        [string retain];
		[_string release];
		_string = [string copy]; // 这里不对了  忘记了 retain新值 释放旧值 赋值新值？？？
	}

见这个https://dayon.gitbooks.io/-ios/content/chapter5.html  ——————————gegege—————我是分割线—————
就是让自己的类有copy功能，
让类遵守<NSCopying>协议，重写- (id)copyWithZone:(NSZone *)zone方法，如果还有其他的需要深度拷贝的内容，需要注意，采用深度拷贝 相应的数据集合。
浅拷贝：
- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self class] allocWithZone:zone] 
                     initWithName:_name
                                  age:_age
                                  sex:_sex];
    return copy;
}

浅拷贝拷贝(包括一个数据集合)：
- (id)copyWithZone:(NSZone *)zone {
    CYLUser *copy = [[[self class] allocWithZone:zone]
                     initWithName:_name
                     age:_age
                     sex:_sex];
    copy->_friends = [_friends mutableCopy];
    return copy;
}

深拷贝：
- (id)deepCopy {
    CYLUser *copy = [[[self class] allocWithZone:zone]
                     initWithName:_name
                     age:_age
                     sex:_sex];
    copy->_friends = [[NSMutableSet alloc] initWithSet:_friends
                                             copyItems:YES];
    return copy;
}


关于 如何重写带copy关键的字的setter

- (void)setName:(NSString *)name {
    //[_name release];  //MRC
    _name = [name copy];
}

这里有一点：
- (void)setName:(NSString *)name {
    if (_name != name) {
        //[_name release];//MRC
        _name = [name copy];
    }
}
不要在 setter 里进行像 if(_obj != newObj) 这样的判断。（该观点参考链接： How To Write Cocoa Object Setters： Principle 3: Only Optimize After You Measure ）



更加进一步
6、@property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的
	声明 成员属性 在类的存储管理中的存储策略 iva 是实例变量 _变量名字 
实例变量存储在类的什么地方，属性存储在类的什么地方，属性跟实例变量有怎样的关系？

@property的本质是声明了一个属性变量

实例变量 和 属性有什么区别？
有时候 ？？什么时候？属性变量会自动生成一个与属性变量对应的实例变量， 也就是下划线开头的变量，但是如果重写的set get方法，就不会自动为属性变量生成其对应的实例变量了。
实例变量是在实例中以偏移量的方式存储的，有一个实例变量表，里面已偏移量的方式，存储着实例变量。
属性呢？ 怎么存储在类的存储结构中？

@property的本质：
@property ＝ ivar + getter + setter
property有两大概念 ivar(实例变量)  和 存取方法 setter getter

7、@protocol 和 category 中如何使用 @property
通过关联属性 给category添加 使用 @property 增加属性




8、runtime 如何实现 weak 属性  这个比较难 不好说 还是去源码里面找答案吧

runtime 对注册的类， 会进行布局，对于 weak 对象会放入一个 hash 表中。 用 weak 指向的对象内存地址作为 key，当此对象的引用计数为0的时候会 dealloc，假如 weak 指向的对象内存地址是a，那么就会以a为键， 在这个 weak 表中搜索，找到所有以a为键的 weak 对象，从而设置为 nil。

参照源码中 objc_storeWeak()方法的实现

weak修饰的指针 是有默认的值的 默认的nil，也就是初始的值是nil


有关元类的：
元类里面存着类方法列表 给类发消息 会通过这个类isa到元类的方法列表里取查找方法。
当我们发送一个消息给一个NSObject对象时，这条消息会在对象的类对象方法列表里查找
当我们发送一个消息给一个类时，这条消息会在类的Meta Class对象的方法列表里查找
所以这个也就验证了 isa的指向 实例对象的isa指向了类 类的isa指向了其元类

3月9日

1、JsonModel的实现 实现原理是什么 三方内部 各个负责什么 做什么工作
    核心就是用class_copyPropertyList得到类的属性列表，再遍历列表，
对每一个属性：
property_getName(property); 获取model类的每一个成员属性的名字
用property_getAttributes得到每个成员属性的属性的类型，
然后 存储在JSONModel中的 JSONModelClassProperty* p 中

最后用kvc，接可以得到所有的值。

使用的比较关键的方法
objc_property_t *properties = class_copyPropertyList(class, &propertyCount);
property_getName(property); // 获取属性的名字
property_getAttributes(property); // 获取属性的属性


主要实现 在JSONModel.m中 除了这个 还有比较重要的几个对象类
JSONKeyMapper 主要做啥？
JSONModelClassProperty 自定义的属性类型
/** Block, which takes in a property name and converts it to the corresponding JSON key name */
这个block 把一个属性名字 转换成的相应的 JSON key
@property (readonly, nonatomic) JSONModelKeyMapBlock modelToJSONKeyBlock;
2、


3月8日
2、
先好好想一想，想清楚了 再去动手做，二超经常这样跟我说 MT面试的时候，也是给我的中肯的提示，可见 我真的需要 遇到问题的时候，先好好想一想，想清楚了，再动手去做。没有想清楚就去做，会乱糟糟。

1、要知道Podfile.lock的作用，先要看看Podfile.lock是啥，里面有啥，才能知道他的作用。
首先，我们先来看看 AsyncDisplayKitCollectionView Demo中的Podfile文件中的内容
 cat Podfile.lock
PODS:
  - AsyncDisplayKit (2.1):
    - AsyncDisplayKit/PINRemoteImage (= 2.1)
  - AsyncDisplayKit/Core (2.1)
  - AsyncDisplayKit/PINRemoteImage (2.1):
    - AsyncDisplayKit/Core
    - PINRemoteImage/iOS (= 3.0.0-beta.7)
    - PINRemoteImage/PINCache
  - PINCache (3.0.1-beta.2):
    - PINCache/Arc-exception-safe (= 3.0.1-beta.2)
    - PINCache/Core (= 3.0.1-beta.2)
  - PINCache/Arc-exception-safe (3.0.1-beta.2):
    - PINCache/Core
  - PINCache/Core (3.0.1-beta.2)
  - PINRemoteImage/Core (3.0.0-beta.7)
  - PINRemoteImage/iOS (3.0.0-beta.7):
    - PINRemoteImage/Core
  - PINRemoteImage/PINCache (3.0.0-beta.7):
    - PINCache (= 3.0.1-beta.2)
    - PINRemoteImage/Core

DEPENDENCIES:
  - AsyncDisplayKit

SPEC CHECKSUMS:
  AsyncDisplayKit: 28de788f9d6ec573be7662f0fe8931e656357e93
  PINCache: 6d273a6e0754bd26e3f12a38a90dde73cc6a42b2
  PINRemoteImage: ff63baf185088530db6cfa41cb665e2b5126b5c3

PODFILE CHECKSUM: d1264bf0434b7a26df33e64d1d416cb1d2a8ef90

COCOAPODS: 1.2.0
QiaoDandandeiMac:AsyncDisplayKitCollectionView qiaodandan$ 
 首先，里面有 导入的各个库的版本信息 还有指明的依赖 以及specification（标准规格）checksum 检查说明 
以及 Podfile checksum 唯一的哈希值

所以 总结一下说，podfile里面的东西就是记录了三方库的版本信息 以及依赖的库的版本信息为了实现稳定 或者是不被未知 的更改产生错误，比如说两个并发去pod update 可能最终的库的版本 会跟podfile.lock里面记载的不一样，所以 我觉得之所以叫做podfile.lock 可能增删改的时候 都会上锁 保持唯一写。


3月7日
1、突然想起来一个问题 podfile.lock 存在的意义是什么 有什么作用？
2、AsyncDisplayKit 三方库的使用 实现 原理 View 和 Layer的区别  





3月6日
1、View和Layer的关系：
常见的 UIView 和 CALayer 的关系：
	View 持有 Layer 用于显示，View 中大部分显示属性实际是从 Layer 映射而来；
	Layer 的 delegate 在这里是 View，当其属性改变、动画产生时，View 能够得到通知。
	UIView 和 CALayer 不是线程安全的，并且只能在主线程创建、访问和销毁。

2、比较有意义的一个问题 或者是事情 APP的性能问题，流畅度问题 三方asynchronous 
三方：

AsyncDisplayKit的原理 效果 其中有上段  说道 View 和 Layer的关系








3月2日
锁的应用的举例：
非递归锁 再上锁之后再上锁，就会不能正常使用出错。递归锁 可以 层层递归上锁。
1、代码源码上的例子
类初始化的时候 +initialize，设计到对类的两个字段的更改，对类的 CLS_INITIALIZED 和 CLS_INITIALIZING 的修改，全局的 monitor_t类型的 classInitLock 锁就是用来同步对这两个字段的更改操作。保证其不会死锁。其他的线程都会等这个信号释放，只有这个信号释放了，才能做任何的消息发送，在初始化完成的信号释放之前，这些线程都会被挂起等待资源。

2、业务逻辑上的例子：

2月28日

参考：http://blog.leichunfeng.com/blog/2015/06/26/objective-c-associated-objects-implementation-principle/
结合源码，看项目中的实现原理

陌陌T：
1、关联属性的生命周期问题
什么时候被释放 什么时候被移除
如果是copy的，那么在代码块执行完之后，就会被放入自动释放池中，会被释放掉 指针置为nil。当前所在的分类生命周期要结束的时候 会销毁这个分类的时候，这个分类所关联的 retain策略的属性将会被移除 然后被置为nil，释放。


2、关联对象被存储在什么地方，是不是被存放在被关联对象本身的内存中

不是存放在关联类的本身内存之后，是又开辟了一个内存，好像是一个关联对应表，用来存储关联的属性。




2月20日
小龙猫 陌陌T

1、点击事件的响应
一个是事件的分发 一个是响应链的实现
见博客随笔内容：http://www.cnblogs.com/Jordandan/p/6483835.html
期间 两个重要的方法：
- (nullable UIView *)hitTest:(CGPoint)point withEvent:(nullable UIEvent *)event;

 - (BOOL)pointInside:(CGPoint)point withEvent:(nullable UIEvent *)event

响应事件的处理呢？事件的分发，如何调用最终的事件响应方法？？？？这是不是就牵涉到了消息的转发机制？




2、constant * 和 * constant
见demo内容

constant *：const在 * 的左边 是同一种情况 通过指针是不能改变指针所指向的变量的值的
也就是不能通过指针改变指针所指向的变量的值，但是可以通过变量a自己改变变量的值

 * constant：
指针不能变，也就是指针自己的值不能变，也就是指针的指向不能变


3、ARC和MRC的区别，以及ARC怎么实现的，ARC如何知道怎么加retain release？
参考文章：http://bugly.qq.com/bbs/forum.php?mod=viewthread&tid=712  对ARC MRC的理解
https://gold.xitu.io/post/584fe4762f301e00573cafc6
第二个关于 自动释放的原理 还没有掌握

ARC（自动引用计数），无需我们自己显式持有（retain）和释放（release）对象，ARC通过对对像加上所有权修饰符（__strong等），编译器通过对象的所有权修饰符将会自动键入引用计数管理（根据所有权修饰符自动键入retain、release、autorelease）

把这段话copy进来是 要学会 如何去规范的表达一个问题的原因和答案 回答要规范正规化 不能太口头 随意。

4、assign 和weak 的区别
assign：用来修饰基本的数据类型，不会置为nil，可能会指向一个不明确的地址空间
weak：用来修饰对象类型，若引用，当对象释放的时候，其属性也会置为nil，是安全的，不会有野指针，也就是不会指针指向一个不明确的地址空间


5、sdwebimage的实现原理

收获：2Gouzi给的建议很中肯：回答要专业一点，不能太口语化，太业余话。





-1.
消息的发送实现：
对一个实例发送消息的时候，会在该实例对应的类的 methodLists中查找
对一个类发送消息的时候，会在该类的MetaClass的methodLists中查找

每一个实例的isa指针，指向自己的class
每一个类的isa指针，指向自己的meta class

消息的转发实现：如何动态的确定消息的发送？？？
[receiver message]
会转换成
msd_send(receiver,selector)
如果receiver不响应message消息，则会去父类查找，父类还不响应，继续去父类查找，如果一直查找到NSObject还不响应，则会进入消息动态处理流程。

消息动态处理流程：








1、[super init]的作用超类完成自己的初始化工作

http://www.jianshu.com/p/9b36e1b636d8
对于self ＝ [super init]的思考：

对象初始化有两种方式：[class new] 与 [[class alloc] init]
［［class alloc］ init］有分配和初始化的过程，alloc 从应用程序的虚拟地址空间上为该对象分配足够的内存，并且将新对象的引用计数加1、将对象的成员变量初始为零，init 会做真正的初使化工作，为对象的实例变量赋予合理有用的值。

[class new]默认调用 alloc与init方法，那么我们无法使用自定义的初始化方法，多了更多的局限性。那么[class alloc] init] 会更方便

为什么这样写？
- (instancetype)init
{
    if (self = [super init]) {
        // Custom initialization
    }
    return self;
}
alloc返回一个有效的未初始化的对象实例。对于self是alloc 返回的指针，同时可以在所有的方法作用域内访问。
但是对于 super，它只是一个 "编译器指示符",告诉编译器在父类中搜索方法的实现。
优先调用[super init] 是为了使超类完成它们自己的初始化工作。
if (self = [super init])
防止父类初始化失败，如果初始化一个对象失败，就会返回nil，当返回nil的时候self = [super init]测试的主体就不会再继续执行。如果不这样做，你可能会操作一个不可用的对象，它的行为是不可预测的，最终可能会导致你的程序崩溃
理解 Self & Super

@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self)
    {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end

self表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。在本例中，无论是[self class]还是[super class]，接受消息者都是Son对象，但super与self不同的是，self调用class方法时，是在子类Son中查找方法，而super调用class方法时，是在父类Father中查找方法。
objc_msgSend（）
objc_msgSendSuper（）

类，父lei，meta class的图？？？？
找到之后补充在这里


引申：
isKindOfClass和isMemberOfClass的区别：
    QDSon * son1 = [[QDSon alloc] init];
    QDSon * son2 = [QDSon new];
    NSLog(@"%@",[son1 class]);
    NSLog(@"%d",[son1 isKindOfClass:[QDSon class]]);//1
    NSLog(@"%d", [son1 isKindOfClass:[QDFather class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDSon class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDFather class]]);//0
    
    //isKindOfClass 判断 认可继承关系 判断是否是本类及子类
    //isMemberOfClass 判断 不认可继承关系 判断是否是本类





2、画圆，画圆角4+1（CC）=5中方式   第一种：使用drawRect方法绘图自定义一个View，在其drawRect方法中操作，尽量避免使用drawRect方法，会耗性能，资源浪费	- (void)drawRect:(CGRect)rect {//一个不透明类型的Quartz 2D绘画环境，相当于一个画布,你可以在上面任意绘画 //获取绘图上下文       CGContextRef context = UIGraphicsGetCurrentContext();设置各种字体颜色 格式最后用CGContextDrawPath方法，画在画布上   CGContextDrawImage画图片} 第二种：设置secondView.layer.cornerRadius = 50;    secondView.layer.masksToBounds = YES;     会引起离屏渲染第三种：使用贝塞尔曲线UIBezierPath和Core Graphics框架在图片的绘图上下文中画出一个透明的圆。增加CPU负担，增加内存开销    UIImageView *imageViewTwo = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageViewTwo.image = [UIImage imageNamed:@"imageName1.jpg"];    //开始对imageView进行画图，在透明的这个imageView的画布上开始画    UIGraphicsBeginImageContextWithOptions(imageViewTwo.bounds.size, NO, [UIScreen mainScreen].scale);//    UIGraphicsBeginImageContextWithOptions(<#CGSize size#>, <#BOOL opaque#>, <#CGFloat scale#>)    //opaque：不透明    //使用贝塞尔曲线画出一个圆形图，并且切掉其他的，就剩下了透明的想要的那个圆    [[UIBezierPath bezierPathWithRoundedRect:imageViewTwo.bounds cornerRadius:imageViewTwo.frame.size.width] addClip];//    + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;     //rounds all corners with the same horizontal and vertical radius    [imageViewTwo drawRect:imageViewTwo.bounds];        imageViewTwo.image = UIGraphicsGetImageFromCurrentImageContext();    //结束画图    UIGraphicsEndImageContext();    [self.view addSubview:imageViewTwo];          第四种：使用CAShapeLayer和UIBezierPath设置圆角，设置view.layer.mask同样会触发离屏渲染。    UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageView.image = [UIImage imageNamed:@"imageName1.jpg"];        UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];        CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init];    //设置大小    maskLayer.frame = imageView.bounds;    //设置图形样子    maskLayer.path = maskPath.CGPath;    imageView.layer.mask = maskLayer;        [self.view addSubview:imageView];第五种：CC的方法，addsubLayerUIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 80, 80)];            [imageView setImage:[UIImage imageNamed:@"AppIcon60x60"]];            CAShapeLayer * layer = [CAShapeLayer layer];            UIBezierPath * path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 80, 80)];            UIBezierPath * circlePath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 80, 80)];            [path appendPath:circlePath];            [path setUsesEvenOddFillRule:YES];            [path addClip];            layer.path = path.CGPath;//            layer.fillColor = [UIColor whiteColor].CGColor;//改成跟北京色一致的            layer.fillColor = [UIColor colorWithRed:240/255.f green:240/255.f blue:240/255.f alpha:1].CGColor;            layer.fillRule = kCAFillRuleEvenOdd;            [imageView.layer addSublayer:layer];            [cell.contentView addSubview:imageView]; 第六种：混合两个imageView，遮盖下面的那个，形成圆角需要切图配合，更直接的，就直接让切图给一个圆角图就可以了。总结：尽量避免重写 drawRect 方法。不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 * 1134 * 4 字节 ≈ 3.4 Mb 的内存。在 内存恶鬼drawRect 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。最基础的一种UIView.layer.cornerRadiusmaskToBounse =yes设置 masksToBounds 会导致离屏渲染，出现性能降低 label 的四周出现了黄色的标记，说明这里出现了离屏渲染高效设置圆角为普通的 UIView设置圆角，和为 UIImageView 设置圆角的原理截然不同。有什么不同？离屏渲染：指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。3、tabBar左右滑动的问题再由tabBar的页面左右，左右滑动的时候，有时候，tabbar不能跟着页面滑动？
4、tableView加timer    什么情况下，timer不能正常的释放掉，什么可以使timer正常的释放掉。见YYFPSLabel的实现。
常见会有bug，tableview滚动会影响timer，tableview滚动的时候，咱阻塞timer，这说明timer添加到的RunLoop的mode不对，需要提高model的优先级，
有三个mode：
NSDefaultRunLoopMode - 标准优先级
NSRunLoopCommonModes -这种解决方式是将 Timer 加入到顶层的 RunLoop 的 "commonModeItems" 中。"commonModeItems" 被 RunLoop 自动更新到所有具有"Common"属性的 Mode 里去。
UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
5、客户详情的右上角的聚合按钮6、keyWindow的问题见仿写iOS系统的浮动聚合按钮的demo？？8、mjrefresh实现9、ASI   AFN10、srwebsocket  内部实现   保活机制12、界面等比放大13、ARC 下 viewdidload 中定义的变量什么时候会释放14、数据库升级
15、uicontrol   uiresponse16、block  为啥不能修改局部变量17、内存管理  strong weak18、自动释放池  三个，加到哪一个19、KVC   KVO21、static  22、http  和  https23、iOS目录结构24、framework   .a   静态库和动态库25、socket26、bitcode27、死锁产生的条件，怎么避免
四个必要条件：
1、互斥条件    
2、请求与保持   
3、不剥夺条件    
4、循环等待条件28、TCP和UDP

tcp协议和udp协议的差别 

             TCP           UDP 
是否连接      面向连接         面向非连接 
传输可靠性    可靠            不可靠 
应用场合      传输大量数据      少量数据 
速度         慢              快



TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来，其中的过程非常复杂，我们这里只做简单、形象的介绍，你只要做到能够理解这个过程即可。我们来看看这三次对话的简单过程：主机A向主机B发出连接请求数据包：“我想给你发数据，可以吗？”，这是第一次对话；主机B向主机A发送同意连接和要求同步（同步就是两台主机一个在发送，一个在接收，协调工作）的数据包：“可以，你什么时候发？”，这是第二次对话；主机A再发出一个数据包确认主机B的要求同步：“我现在就发，你接着吧！”，这是第三次对话。三次“对话”的目的是使数据包的发送和接收同步，经过三次“对话”之后，主机A才向主机B正式发送数据。 

UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ 
  UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。比如，我们经常使用“ping”命令来测试两台主机之间TCP/IP通信是否正常，其实“ping”命令的原理就是向对方主机发送UDP数据包，然后对方主机确认收到数据包，如果数据包是否到达的消息及时反馈回来，那么网络就是通的。例如，在默认状态下，一次“ping”操作发送4个数据包（如图2所示）。大家可以看到，发送的数据包数量是4包，收到的也是4包（因为对方主机收到后会发回一个确认收到的数据包）。这充分说明了UDP协议是面向非连接的协议，没有建立连接的过程。正因为UDP协议没有连接的过程，所以它的通信效果高；但也正因为如此，它的可靠性不如TCP协议高。QQ就使用UDP发消息，因此有时会出现收不到消息的情况。 




网络的5层分层模型：
物理层，数据链路层，网络层，运输层，应用层

TCP/IP协议在分别是什么层的协议？
UDP层是什么层的协议，数据报

滑动窗口协议是哪个层的协议？





29、userdefault  存储的数据能通过物理路径找到吗31、深入理解RunLoop32、深入理解GCD
见GCDNotes.txt里面包括了1和2

3：dispatch source
4：dispatch queue挂起和dispatch queue目标锁定和信号量 




33、定时帧NSTimer和CADisplayLink
见博客http://www.cnblogs.com/Jordandan/p/6197273.html
定时帧




30、获取帧率见YYFPSLabel的实现，博客的记录





31、block中修改变量的问题

 block 的目的是为了支持并行编程，对于普通的 local 变量，我们就不能在 block 里面随意修改
（原因很简单，block 可以被多个线程并行运行，会有问题的）
   而且如果你在 block 中修改普通的 local 变量，编译器也会报错。那么该如何修改外部变量呢？
有两种办法，
第一种是可以修改 static变量把变量变成 全局变量；
第二种是可以修改用新关键字 __block 修饰的变量。

请看：
    NSAutoreleasePool * pool = [[NSAutoreleasePool alloc] init];
    
    __block int blockLocal  = 100;
    static int staticLocal  = 100;
    
    void (^aBlock)(void) = ^(void){ 
        NSLog(@" >> Sum: %d\n", global + staticLocal);
        
        global++;
        blockLocal++;
        staticLocal++;
    };
    
    aBlock();

    NSLog(@"After modified, global: %d, block local: %d, static local: %d\n", global, blockLocal, staticLocal);

    [pool release];

执行之后，值均为：101





32、
for 
for-in：快速枚举，对于可变数组进行枚举操作时，不能通过添加或删除对象等这类操作来改变数组容器,否则就会报错.而本身这种操作也是有问题的，数组容器已经改变，可能遍历到没有分配的位置，用for循环机器不能自己察觉，但是枚举器可以察觉。

EnumerateObjectsUsingBlock
enumerateKeysAndObjectsUsingBlock
enumerateObjectsWithOptions

1.
enumerateObjectsUsingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }

2.
enumerateObjectsWithOptions:<#(NSEnumerationOptions)#> usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }

3.
enumerateObjectsAtIndexes:<#(nonnull NSIndexSet *)#> options:<#(NSEnumerationOptions)#> usingBlock:^(id  _Nonnull obj, NSUInteger idx, BOOL * _Nonnull stop) {
        
    }




33、instrument的使用
Timer Profiler时间分析器
Allocations 内存分配使用情况
内存泄露僵尸对象
循环引用
FPS
离屏渲染
CoreAnimation动画执行





34、内存划分五大区：
1、代码区
1、全局区，静态区：全局变量和静态变量的存储是放在一起的，初始化的全局变量和静态变量放在一块区域，未初始化的静态变量和未初始化的动态变量是在相邻的区域的，程序结束后系统释放。
3、常量区：常量字符串就是放在这里
4、栈：一般由编译器操作，会存放一些局部变量，等。
5、堆：一般由程序员管理，比如alloc申请内存，一般的对象都在堆区。（链表

35、
strong：
weak：

weak和strong不同的是：当一个对象不再有strong类型的指针指向它的时候 它会被释放  ，即使还有weak型指针指向它。
一旦最后一个strong型指针离去 ，这个对象将被释放，所有剩余的weak型指针都将被清除。

可能有个例子形容是妥当的。

想象我们的对象是一条狗，狗想要跑掉（被释放）。

strong型指针就像是栓住的狗。只要你用牵绳挂住狗，狗就不会跑掉。如果有5个人牵着一条狗（5个strong型指针指向1个对象），除非5个牵绳都脱落 ，否着狗是不会跑掉的。

weak型指针就像是一个小孩指着狗喊到：“看！一只狗在那” 只要狗一直被栓着，小孩就能看到狗，（weak指针）会一直指向它。只要狗的牵绳脱落，狗就会跑掉，不管有多少小孩在看着它。

只要最后一个strong型指针不再指向对象，那么对象就会被释放，同时所有的weak型指针都将会被清除。



copy：建立一个索引计数为1的对象，然后释放旧对象。对NSString。对NSString 


retain：释放旧的对象，将旧对象的值赋予输入对象，再提高输入对象的索引计数为1 。对其他NSObject和其子类 


copy和retain的区别：

copy其实是建立了一个相同的对象，而retain不是；

copy是内容拷贝，retain是指针拷贝；

copy是内容的拷贝 ,对于像NSString,的确是这样，但是如果拷贝的是NSArray这时只是copy了指向array中相对应元素的指针.这便是所谓的"浅复制"。



assign： 简单赋值，不更改索引计数（Reference Counting）。对基础数据类型 （NSInteger，CGFloat）和C数据类型（int, float, double, char, 等等）
unsafe_unretain：
autoreleaseing：



__block和__weak修饰符的区别：

__block不管是ARC还是MRC模式下都可以使用，可以修饰对象，还可以修饰基本数据类型。

__weak只能在ARC模式下使用，也只能修饰对象（NSString），不能修饰基本数据类型（int）。

__block对象可以在block中被重新赋值，__weak不可以。


36、分类和扩展：
扩展是无名分类，
扩展里面的属性，是私有的，子类也访问不了。
能为某个类附加额外的属性，成员变量，方法声明
一般的类扩展写到.m文件中
一般的私有属性写到类扩展


分类可以通过关联实现属性
分类只能扩充方法，不能扩展属性和成员变量（如果包含成员变量会直接报错）。
如果分类中声明了一个属性，那么分类只会生成这个属性的set、get方法声明，也就是不会有实现。
但是扩展不可以？？？不可以什么？？？不可以生成属性的set get方法,不可以添加属性和成员变量

37、Charles实现对Https进行抓包，使用的原理就是中间人技术（man-in-the-middle）中间人技术（man-in-the-middle）：

38、
NSURLSession总结：

1、分有普通、上传和下载 三种不同的网络请求任务：
NSURLSessionDataTask, NSURLSessionUploadTask和NSURLSessionDownloadTask
2、创建的task都是挂起状态，需要resume才能执行。
3、NSURLSessionUploadTask下载文件，会默认下载到沙盒中的tem文件夹中，不会出现内存暴涨的情况，但在下载完成后会将tem中的临时文件删除，需要在初始化任务方法时，在completionHandler回调中增加保存文件的代码。

实例化网络下载任务时将下载的文件保存到沙盒的caches文件夹中：

[NSURLSessionDownloadTask [NSURLSessionDownloadTask *task = [session downloadTaskWithURL:[NSURL URLWithString:@"http://127.0.0.1/dawenjian.zip"] completionHandler:^(NSURL * _Nullable location, NSURLResponse * _Nullable response, NSError * _Nullable error) {
   //获取沙盒的caches路径
   NSString *path = [[NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES)lastObject]stringByAppendingPathComponent:@"kkk.dmg"];
   //生成URL路径
   NSURL *DCurl = [NSURL fileURLWithPath:path];
   //将文件保存到沙盒指定文件目录下
   [[NSFileManager defaultManager]moveItemAtURL:location toURL:DCurl error:nil];   }]resume];

4、NSURLSession有三个控制方法，取消（cancel），暂停（suspend），继续（resume），暂停后可以通过继续恢复当前的请求任务。

5、NSURLSession进行断点下载，当暂停下载任务后，如果 downloadTask （下载任务）为非空，调用 cancelByProducingResumeData:(void (^)(NSData *resumeData))completionHandler 这个方法，这个方法接收一个参数，完成处理代码块，这个代码块有一个 NSData 参数 resumeData，如果 resumeData 非空，我们就保存这个对象到视图控制器的 resumeData 属性中。在点击再次下载时，通过调用 
[ [self.session downloadTaskWithResumeData:self.resumeData]resume]方法进行继续下载操作。   

6、
NSURLSession的构造方法（sessionWithConfiguration:delegate:delegateQueue）中有一个 NSURLSessionConfiguration类的参数可以设置配置信息，其决定了cookie，安全和高速缓存策略，最大主机连接数，资源管理，网络超时等配置。NSURLConnection不能进行这个配置，相比于 NSURLConnection 依赖于一个全局的配置对象，缺乏灵活性而言，NSURLSession 有很大的改进了。

NSURLSession可以设置三种配置信息，分别通过调用三个累方法返回配置对象：

+ (NSURLSessionConfiguration *)defaultSessionConfiguration
配置信息使用基于硬盘的持久话Cache，保存用户的证书到钥匙串,使用共享cookie存储；
+ (NSURLSessionConfiguration *)ephemeralSessionConfiguration 
配置信息和default大致相同。除了，不会把cache，证书，或者任何和Session相关的数据存储到硬盘，而是存储在内存中，生命周期和Session一致。比如浏览器无痕浏览等功能就可以基于这个来做；
+ (NSURLSessionConfiguration *)backgroundSessionConfigurationWithIdentifier:(NSString *)identifier
配置信息可以创建一个可以在后台甚至APP已经关闭的时候仍然在传输数据的session。
注意，后台Session一定要在创建的时候赋予一个唯一的identifier，这样在APP下次运行的时候，能够根据identifier来进行相关的区分。如果用户关闭了APP,IOS 系统会关闭所有的background Session。而且，被用户强制关闭了以后，IOS系统不会主动唤醒APP，只有用户下次启动了APP，数据传输才会继续。

39、断点续传


40、各种锁汇总：

1、NSLock
遵循NSLocking协议

lock消息
unlock消息

连续锁两次会死锁，不能正常，多次的要用递归锁

2、NSRecursiveLock
可以被一个线程多次获得，而不会引起死锁
故名思议，是在递归中用的，不会引起死锁失效

3、NSCondition
算是同步锁
可以实现不同线程的调度
一个线程被某一个条件所阻塞，直到另一个线程满足该条件从而发送信号给该线程使得该线程可以正确的执行。
发送信号之后，解锁开锁。

4、NSConditionLock
NSConditionLock 对象所定义的互斥锁可以在使得在某个条件下进行锁定和解锁。
和 NSCondition 很像，但实现方式是不同的。
两个线程需要特定顺序执行的时候，例如生产者消费者模型，则可以使用 NSConditionLock 。当生产者执行执行的时候，消费者可以通过特定的条件获得锁，当生产者完成执行的时候，它将解锁该锁，然后把锁的条件设置成唤醒消费者线程的条件。锁定和解锁的调用可以随意组合，lock 和 unlockWithCondition: 配合使用 lockWhenCondition: 和 unlock 配合使用。

- (void)producer {
    while (YES) {
        [self.conditionLock lock];
        NSLog(@"have something");
        self.count++;
        [self.conditionLock unlockWithCondition:1];
    }
}

- (void)consumer {
    while (YES) {
        [self.conditionLock lockWhenCondition:1];
        NSLog(@"use something");
        self.count--;
        [self.conditionLock unlockWithCondition:0];
    }
}

5、pthread_mutex
互斥锁是一种超级易用的互斥锁，使用的时候，只需要初始化一个 pthread_mutex_t 用 pthread_mutex_lock 来锁定 pthread_mutex_unlock 来解锁，当使用完成后，记得调用 pthread_mutex_destroy 来销毁锁。

6、pthread_rwlock

读写锁，在对文件进行操作的时候，写操作是排他的，一旦有多个线程对同一个文件进行写操作，后果不可估量，但读是可以的，多个线程读取时没有问题的。

当读写锁被一个线程以读模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程还可以继续进行。
当读写锁被一个线程以写模式占用的时候，写操作的其他线程会被阻塞，读操作的其他线程也被阻塞。

7、POSIX Conditions
POSIX 条件锁需要互斥锁和条件两项来实现，虽然看起来没什么关系，但在运行时中，互斥锁将会与条件结合起来。线程将被一个互斥和条件结合的信号来唤醒。

首先初始化条件和互斥锁，当 ready_to_go 为 flase 的时候，进入循环，然后线程将会被挂起，直到另一个线程将 ready_to_go 设置为 true 的时候，并且发送信号的时候，该线程会才被唤醒。

8、OSSpinLock
自旋锁，和互斥锁类似，都是为了保证线程安全的锁。但二者的区别是不一样的，对于互斥锁，当一个线程获得这个锁之后，其他想要获得此锁的线程将会被阻塞，直到该锁被释放。但自选锁不一样，当一个线程获得锁之后，其他线程将会一直循环在哪里查看是否该锁被释放。所以，此锁比较适用于锁的持有者保存时间较短的情况下。
YY大神有

9、os_unfair_lock
iOS 10新出的解决自选锁失效的问题

10、dispatch_semaphore
信号量机制实现锁，等待信号，和发送信号，正如前边所说的看门人一样，当有多个线程进行访问的时候，只要有一个获得了信号，其他线程的就必须等待该信号释放。

11、@synchronized
一个便捷的创建互斥锁的方式，它做了其他互斥锁所做的所有的事情。


应当针对不同的操作使用不同的锁：

1、当进行文件读写的时候，使用 pthread_rwlock 较好，文件读写通常会消耗大量资源，而使用互斥锁同时读文件的时候会阻塞其他读文件线程，而 pthread_rwlock 不会。

2、当性能要求较高时候，可以使用 pthread_mutex 或者 dispath_semaphore，由于 OSSpinLock 不能很好的保证线程安全，而在只有在 iOS10 中才有 os_unfair_lock ，所以，前两个是比较好的选择。既可以保证速度，又可以保证线程安全。

3、对于 NSLock 及其子类，速度来说 NSLock < NSCondition < NSRecursiveLock < NSConditionLock 。


41、生产者消费者

42、NSCoreData

43、其他的本地化

44、
C语言的问题

45、数据结构的问题
链表，矩阵

46、swift的小demo

48、哈希碰撞解决方法：
1、线性的，往后推到下一个空的位置
2、非线性的，再一次哈希
3、链地址，在这个位置放置一个链表，放置哈西之后存在该位置的元素
4、建立一个公共溢出区，放置这些，这个没有印象啦


47、SDwebimage的源码复习

SDWebImageManager
SDWebImageDownloader


SD失效的问题可能解决方案：

1、有可能是图片的url地址不对，有可能浏览器可以打开，但是这个地址浏览器是做了处理的，所以浏览器能打开。

2、如果图片地址是Http，那么就需要关闭ATS。

ATS (App Transport Security)

新特性要求App内访问的网络必须使用HTTPS协议，

我们这里只是说明一下如何关闭该特性,让其可以访问http开头的网址.

关闭很简单,打开项目中的info.plist文件,在其中添加一个字典类型的项目App Transport Security Settings,然后在其中添加一个key:Allow Arbitrary Loads,其值为YES,


- (void)sd_setImageWithURL:(NSURL *)url placeholderImage:(UIImage *)placeholder options:(SDWebImageOptions)options progress:(SDWebImageDownloaderProgressBlock)progressBlock completed:(SDWebImageCompletionBlock)completedBlock 

有全能初始化方法（designated initializer）的概念，这个方法也就相当于是全能操作方法，所有的方法最后都会调用这个方法，都会集中到这个方法中执行

1、方法中先进行了一个关联
static char imageURLKey;
将传过来的url 设置成imageURLKey的value，由于imageURLKey是指向char类型的一个指针，所以是& imageURLKey，value是url。

2、placeholder有的话，先设置上placeholder图片

3、然后对非空的url进行图片的请求，交给了单例的SDWebImageManager，还有相应的SDWebImageOperation协议，以及相应的协议方法

id <SDWebImageOperation> operation 
协议中有唯一的
- (void)cancel;
方法

SDWebImageManager
中的方法
- (id <SDWebImageOperation>)downloadImageWithURL:(NSURL *)url
                                         options:(SDWebImageOptions)options
                                        progress:(SDWebImageDownloaderProgressBlock)progressBlock
                                       completed:(SDWebImageCompletionWithFinishedBlock)completedBlock {

里面还有一个self.failedURLs数组，所有的失败的url都会放里面，这个数组作为公共资源，需要考虑线程安全，所以用 @synchronized (self.failedURLs) {进行了加锁操作来访问和修改，这是对数据请求进行的优化，对于失败的url的数据请求进项了改进，不会一直请求失败的url占用资源。

5、然后对于正常的数据请求：

添加进入 runningOperations 之中。

还有一个重要的类SDWebImageCombinedOperation

@property (strong, nonatomic) NSOperation *cacheOperation;

cacheOperation是NSOperation




designate 
 | BrE ˈdɛzɪɡnət, AmE ˈdɛzɪɡnət, ˈdɛzɪɡˌneɪt |
formal (appointed)受委派而尚未上任的 shòu wěipài ér shàngwèi shàngrèn de (elected)已当选而尚未就职的 yǐ dāngxuǎn ér shàngwèi jiùzhí de
prime minister designate
新当选而尚未上任的首相


http://www.jianshu.com/p/4191017c8b39
SD总结：
SDWebImageAllowInvalidSSLCertificates 允许使用无效的SSL证书，主要用于测试目的，在正式环境中慎用
SDWebImageHighPriority 优先下载
SDWebImageDelayPlaceholder 等待下载完成后再显示占位图片，延迟显示占位图片
SDWebImageTransformAnimatedImage 改变动画形象
SDWebImageAvoidAutoSetImage 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上

options 枚举：

1、SDWebImageRetryFailed 失败后重试， 默认如果下载失败,这个url会被加入黑名单并且不会尝试再次下载,设置这个枚举会阻止把失败的url加入黑名单，不断尝试重新下载

2、SDWebImageLowPriority 延迟下载， 默认情况下,图片会在交互发生的时候下载(例如你滑动tableview的时候),这个枚举会禁止这个特性,导致的结果就是在scrollview减速的时候才会开始下载(也就是你滑动的时候scrollview不下载,你手从屏幕上移走,scrollview开始减速的时候才会开始下载图片)

3、SDWebImageCacheMemoryOnly 只在内存缓存

4、SDWebImageProgressiveDownload 渐进式下载,显示的图像是逐步在下载

很重要
5、SDWebImageRefreshCached 刷新缓存，有时本地图片更新后与服务器没有同步一致时可以使用（例如更新头像），专门处理相同url，但不同image的情况的
原因：默认情况下，SDWebImage会忽略Header中的缓存设置，将图片以url为key进行保存，url与图片是一一对应关系。所以请求同一个url时，SDWebImage会从缓存中取得图片。一般的情况下用此方法可以满足我们的应用要求，但是如果你请求同一个url，而这张图片在服务器端更新了，本地客户端再次请求时还是会返回缓存中的旧图片，例如加载头像类经常更新的图片时，就会出现头像不能更新的问题，由于url与图片一一对应，一种解决的办法是改变部分url地址方式实现更新，不过这种方法操作起来很复杂， 另一种将第三个参数设置为SDWebImageRefreshCached就可以实现图片更新操作了。



6、SDWebImageContinueInBackground 启动后台下载，app进入后台后继续下载

7、SDWebImageHandleCookies 处理存储在NSHTTPCookieStore中的cookie
NSMutableURLRequest.HTTPShouldHandleCookies = YES;

8、SDWebImageAllowInvalidSSLCertificates 允许使用无效的SSL证书，主要用于测试目的，在正式环境中慎用

9、SDWebImageHighPriority 优先下载

10、SDWebImageDelayPlaceholder 等待下载完成后再显示占位图片，延迟显示占位图片

11、SDWebImageTransformAnimatedImage 改变动画形象

12、SDWebImageAvoidAutoSetImage 下载完成后手动设置图片，默认是下载完成后自动放到ImageView上


48、https

2017年1月24日—————————————————————————

49、遇到的一个问题的结局：
https验证证书的问题
问题描述：web页面有一个动态gif的表情一直不能成功显示出来，

<img src=“https://img2.soufun.com/bbsv2/face/em016.gif”>

用NSUrlSession请求之后，错误信息是这个：

Error Domain=NSURLErrorDomain Code=-1202 "此服务器的证书无效。您可能正在连接到一个伪装成“img2.soufun.com”的服务器，这会威胁到您的机密信息的安全。" UserInfo={NSURLErrorFailingURLPeerTrustErrorKey=<SecTrustRef: 0x608000116020>, NSLocalizedRecoverySuggestion=您仍要连接此服务器吗？, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9843, NSErrorPeerCertificateChainKey=(
    "<cert(0x7ffbba8ec000) s: *.cdn.myqcloud.com i: Symantec Class 3 Secure Server CA - G4>",
    "<cert(0x7ffbba8cc000) s: Symantec Class 3 Secure Server CA - G4 i: VeriSign Class 3 Public Primary Certification Authority - G5>",
    "<cert(0x7ffbba8eca00) s: VeriSign Class 3 Public Primary Certification Authority - G5 i: Class 3 Public Primary Certification Authority>",
    "<cert(0x7ffbba8cc800) s: Class 3 Public Primary Certification Authority i: Class 3 Public Primary Certification Authority>"
), NSUnderlyingError=0x61800024c900 {Error Domain=kCFErrorDomainCFNetwork Code=-1202 "(null)" UserInfo={_kCFStreamPropertySSLClientCertificateState=0, kCFStreamPropertySSLPeerTrust=<SecTrustRef: 0x608000116020>, _kCFNetworkCFStreamSSLErrorOriginalValue=-9843, _kCFStreamErrorDomainKey=3, _kCFStreamErrorCodeKey=-9843, kCFStreamPropertySSLPeerCertificates=(
    "<cert(0x7ffbba8ec000) s: *.cdn.myqcloud.com i: Symantec Class 3 Secure Server CA - G4>",
    "<cert(0x7ffbba8cc000) s: Symantec Class 3 Secure Server CA - G4 i: VeriSign Class 3 Public Primary Certification Authority - G5>",
    "<cert(0x7ffbba8eca00) s: VeriSign Class 3 Public Primary Certification Authority - G5 i: Class 3 Public Primary Certification Authority>",
    "<cert(0x7ffbba8cc800) s: Class 3 Public Primary Certification Authority i: Class 3 Public Primary Certification Authority>"
)}}, NSLocalizedDescription=此服务器的证书无效。您可能正在连接到一个伪装成“img2.soufun.com”的服务器，这会威胁到您的机密信息的安全。, NSErrorFailingURLKey=https://img2.soufun.com/bbsv2/face/em016.gif, NSErrorFailingURLStringKey=https://img2.soufun.com/bbsv2/face/em016.gif, NSErrorClientCertificateStateKey=0}

是https客户端需要验证这个域名的自签名证书的问题，

后查实，项目中的图片的域名需要进行收敛操作，只有将域名进行收敛操作之后，相应的域名的站点才有相应的证书，收敛表情上传之前的表情的url即可。相应的域名受凉犯法也根据需求扩充了一下。

还有我新加入的头像也显示不正常，猜测也是这个问题。


3、用户头像不能显示的问题：

web页中的url
http://img8.soufunimg.com/viewimage/zxb/2015_11/12/m05/01/c8/wkgeqlzemjmibv3qaaqajiha7kyaajzrandul4abbqk579/156x156c.jpg"

http://img8.soufunimg.com/viewimage/zxb/2015_11/12/M05/01/C8/wKgEQlZEMjmIbv3qAAQajIhA7kYAAJzRANDUL4ABBqk579/156x156c.jpg


img src的路径就有问题
虽然域名协议不区分大小写
但是路径可能区分大小写
所以 一模一样的url img 的src 是小写的
访问不到这个图片
我的 url是大小写区分的 可以访问到
所以 这个图片本身就访问不到 现在做收敛了也找不到
只能这个图片能访问到了 才能做收敛


1月23日 MT有关问题总结：

问题总结，
1、有关推送的
2、有关weak原理的
3、加分隔符的
4、快排实现
5、load 和 initlizer
6、swizzling
7、实现能力
8、一个view上面添加了按钮，按钮在view的边缘，有什么问题 1月24日想起扩充
9、响应链的问题，button超出父控件的问题
10、jsonModel的实现原理
11、UIView和layer的关系



自己太大意了，最基础的都没有做好，希望自己认识自己，改正不足的地方。
感谢MT，感谢我的朋友。感谢一直陪伴我的CC，我会努力的。


