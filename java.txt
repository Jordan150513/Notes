java 
2017年3月17日
继续：从Java APPlet开始继续
http://www.runoob.com/java/java-applet-basics.html

Java Applet 先不看 看了也不用
开始Java 实例





2017年3月16日

java.net 包中提供了两种常见的网络协议的支持：
* TCP：TCP 是传输控制协议的缩写，它保障了两个应用程序之间的可靠通信。通常用于互联网协议，被称 TCP / IP。
* UDP：UDP 是用户数据报协议的缩写，一个无连接的协议。提供了应用程序之间要发送的数据的数据包。

socket通信：
	套接字使用TCP提供了两台计算机之间的通信机制。 客户端程序创建一个套接字，并尝试连接服务器的套接字。
当连接建立时，服务器会创建一个 Socket 对象。客户端和服务器现在可以通过对 Socket 对象的写入和读取来进行进行通信。
java.net.Socket 类代表一个套接字，并且 java.net.ServerSocket 类为服务器程序提供了一种来监听客户端，并与他们建立连接的机制。

两台计算机之间使用套接字建立TCP连接时会出现：
* 服务器实例化一个 ServerSocket 对象，表示通过服务器上的端口通信。
* 服务器调用 ServerSocket 类的 accept() 方法，该方法将一直等待，直到客户端连接到服务器上给定的端口。
* 服务器正在等待时，一个客户端实例化一个 Socket 对象，指定服务器名称和端口号来请求连接。
* Socket 类的构造函数试图将客户端连接到指定的服务器和端口号。如果通信被建立，则在客户端创建一个 Socket 对象能够与服务器进行通信。
* 在服务器端，accept() 方法返回服务器上一个新的 socket 引用，该 socket 连接到客户端的 socket。

	连接建立后，通过使用 I/O 流在进行通信，每一个socket都有一个输出流和一个输入流，客户端的输出流连接到服务器端的输入流，而客户端的输入流连接到服务器端的输出流。
TCP 是一个双向的通信协议，因此数据可以通过两个数据流在同一时间发送.以下是一些类提供的一套完整的有用的方法来实现 socket。


ServerSocket 类
服务器应用程序通过使用 java.net.ServerSocket 类以获取一个端口,并且侦听客户端请求。

Socket 类
java.net.Socket 类代表客户端和服务器都用来互相沟通的套接字。客户端要获取一个 Socket 对象通过实例化 ，而 服务器获得一个 Socket 对象则通过 accept() 方法的返回值。
客户端和服务器端都有一个 Socket 对象，所以无论客户端还是服务端都能够调用这些方法。

InetAddress 类
这个类表示互联网协议(IP)地址。

Socket变成 演示socket客户端和服务器端的交互demo：
Socket 客户端实例：

Socket 服务端实例：

Java Socket： client server 通信的demo没有成功 还需要找原因。j
avac编译java文件之后，执行的时候 一直提示
错误: 找不到或无法加载主类 GreetingServer  还没有解决

java发送邮件 

实现发送邮件的demo

java多线程

多线程是多任务的一种特别的形式，但多线程使用了更小的资源开销

进程：一个进程包括由操作系统分配的内存空间，包含一个或多个线程。
一个线程不能独立的存在，它必须是进程的一部分。
一个进程一直运行，直到所有的非守候线程都结束运行后才能结束。
多线程能满足程序员编写高效率的程序来达到充分利用 CPU 的目的。

线程的生命周期：见图：java-thread.jpg

* 新建状态:使用 new 关键字和 Thread 类或其子类建立一个线程对象后，该线程对象就处于新建状态。它保持这个状态直到程序 start() 这个线程。
* 就绪状态:当线程对象调用了start()方法之后，该线程就进入就绪状态。就绪状态的线程处于就绪队列中，要等待JVM里线程调度器的调度。
* 运行状态:如果就绪状态的线程获取 CPU 资源，就可以执行 run()，此时线程便处于运行状态。处于运行状态的线程最为复杂，它可以变为阻塞状态、就绪状态和死亡状态。
* 阻塞状态:如果一个线程执行了sleep（睡眠）、suspend（挂起）等方法，失去所占用资源之后，该线程就从运行状态进入阻塞状态。在睡眠时间已到或获得设备资源后可以重新进入就绪状态。可以分为三种： 
    * 等待阻塞：运行状态中的线程执行 wait() 方法，使线程进入到等待阻塞状态。 
    * 同步阻塞：线程在获取 synchronized 同步锁失败(因为同步锁被其他线程占用)。 
    * 其他阻塞：通过调用线程的 sleep() 或 join() 发出了 I/O 请求时，线程就会进入到阻塞状态。当sleep() 状态超时，join() 等待线程终止或超时，或者 I/O 处理完毕，线程重新转入就绪状态。
* 死亡状态: 一个运行状态的线程完成任务或者其他终止条件发生时，该线程就切换到终止状态。

线程优先级：

每一个 Java 线程都有一个优先级，这样有助于操作系统确定线程的调度顺序。
Java 线程的优先级是一个整数，其取值范围是 1 （Thread.MIN_PRIORITY ） - 10 （Thread.MAX_PRIORITY ）。
默认情况下，每一个线程都会分配一个优先级 NORM_PRIORITY（5）。
具有较高优先级的线程对程序更重要，并且应该在低优先级的线程之前分配处理器资源。但是，线程优先级不能保证线程执行的顺序，而且非常依赖于平台。

创建一个线程：

Java 提供了三种创建线程的方法：
* 通过实现 Runnable 接口；
* 通过继承 Thread 类本身；
* 通过 Callable 和 Future 创建线程

第一种、通过实现Runnable接口 

创建一个实现 Runnable 接口的类。
class RunnableDemo implements Runnable {
}
类只需要执行一个方法调用 run()，可以重写 run()
run() 可以调用其他方法，使用其他类，并声明变量，就像主线程一样。
在创建一个实现 Runnable 接口的类之后，你可以在类中实例化一个线程对象。
新线程创建之后，你调用它的 start() 方法它才会运行。

实现 demo 创建一个实现 Runnable 接口的类。

第二种、通过集成Thread来实现多线程
该类继承 Thread 类，然后创建一个该类的实例。
继承类必须重写 run() 方法，该方法是新线程的入口点。它也必须调用 start() 方法才能执行。
该方法尽管被列为一种多线程实现方式，但是本质上也是实现了 Runnable 接口的一个实例。

Thread 常用方法
1	public void start()
使该线程开始执行；Java 虚拟机调用该线程的 run 方法。
2	public void run()
如果该线程是使用独立的 Runnable 运行对象构造的，则调用该 Runnable 对象的 run 方法；否则，该方法不执行任何操作并返回。
3	public final void setName(String name)
改变线程名称，使之与参数 name 相同。
4	public final void setPriority(int priority)
 更改线程的优先级。
5	public final void setDaemon(boolean on)
将该线程标记为守护线程或用户线程。
6	public final void join(long millisec)
等待该线程终止的时间最长为 millis 毫秒。
7	public void interrupt()
中断线程。
8	public final boolean isAlive()
测试线程是否处于活动状态。

第三种方式  创建多线程
通过 Callable 和 Future 创建线程
* 1. 创建 Callable 接口的实现类，并实现 call() 方法，该 call() 方法将作为线程执行体，并且有返回值。
* 2. 创建 Callable 实现类的实例，使用 FutureTask 类来包装 Callable 对象，该 FutureTask 对象封装了该 Callable 对象的 call() 方法的返回值。
* 3. 使用 FutureTask 对象作为 Thread 对象的 target 创建并启动新线程。
* 4. 调用 FutureTask 对象的 get() 方法来获得子线程执行结束后的返回值。

创建线程的三种方式的对比
* 1. 采用实现 Runnable、Callable 接口的方式创见多线程时，线程类只是实现了 Runnable 接口或 Callable 接口，还可以继承其他类。
* 2. 使用继承 Thread 类的方式创建多线程时，编写简单，如果需要访问当前线程，则无需使用 Thread.currentThread() 方法，直接使用 this 即可获得当前线程。

线程的几个主要概念
在多线程编程时，你需要了解以下几个概念：
* 线程同步
* 线程间通信
* 线程死锁
* 线程控制：挂起、停止和恢复

今天先到这里
明天继续：从Java APPlet开始继续
http://www.runoob.com/java/java-applet-basics.html












2017年3月15日

继承的特性
* 	子类拥有父类非private的属性，方法。
* 	子类可以拥有自己的属性和方法，即子类可以对父类进行扩展。
* 	子类可以用自己的方式实现父类的方法。
* 	Java的继承是单继承，但是可以多重继承，单继承就是一个子类只能继承一个父类，多重继承就是，例如A类继承B类，B类继承C类，所以按照关系就是C类是B类的父类，B类是A类的父类，这是java继承区别于C++继承的一个特性。
* 	提高了类之间的耦合性（继承的缺点，耦合度高就会造成代码之间的联系）。

extends关键字 		实现单继承
implements关键字 		可以变相的使java具有多继承的特性，使用范围为类继承接口的情况，可以同时继承多个接口（接口跟接口之间采用逗号分隔）。

final 关键字声明类可以把类定义为不能继承的，即最终类；或者用于修饰方法，该方法不能被子类重写：

子类不能继承父类的构造器（构造方法或者构造函数），但是父类的构造器带有参数的，则必须在子类的构造器中显式地通过super关键字调用父类的构造器并配以适当的参数列表。
如果父类有无参构造器，则在子类的构造器中用super调用父类构造器不是必须的，如果没有使用super关键字，系统会自动调用父类的无参构造器。

Java 重写(Override)与重载(Overload)

重写是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变。即外壳不变，核心重写！

在子类父类之间

方法的重写规则
* 	参数列表必须完全与被重写方法的相同；
* 	返回类型必须完全与被重写方法的返回类型相同；
* 	访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
* 	父类的成员方法只能被它的子类重写。
* 	声明为final的方法不能被重写。
* 	声明为static的方法不能被重写，但是能够被再次声明。
* 	子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
* 	子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
* 	写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
* 	构造方法不能被重写。
* 	如果不能继承一个方法，则不能重写这个方法。

重载(Overload)

在一个类里面

重载(overloading) 是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同。
每个重载的方法（或者构造函数）都必须有一个独一无二的参数类型列表。

最常用的地方就是构造器的重载。

重载规则
* 	被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
* 	被重载的方法可以改变返回类型；
* 	被重载的方法可以改变访问修饰符；
* 	被重载的方法可以声明新的或更广的检查异常；
* 	方法能够在同一个类中或者在一个子类中被重载。
* 	无法以返回值类型作为重载函数的区分标准。


重写与重载之间的区别
区别点		重载方法		重写方法
参数列表		必须修改		一定不能修改
返回类型		可以修改		一定不能修改
异常			可以修改		可以减少或删除，一定不能抛出新的或者更广的异常
访问			可以修改		一定不能做更严格的限制（可以降低限制）

重写是父类与子类之间多态性的一种表现，重载是一类中多态性的一种表现。

多态存在的三个必要条件
* 继承
* 重写
* 父类引用指向子类对象

虚方法
Employee 父类
Salary 子类
都有mailCheck()方法，两个都是用Salary创建的，一个用Salary引用，一个用父类Employee引用，那么调用mailCheck()方法，编译的时候 是去父类找，但是其实运行起来的，都是用原本类的方法。那个类创建 构造的，用哪个类的方法。

在编译的时候，编译器使用 Employee 类中的 mailCheck() 方法验证该语句， 但是在运行的时候，Java虚拟机(JVM)调用的是 Salary 类中的 mailCheck() 方法。

以上整个过程被称为 虚拟方法调用 ，该方法被称为 虚拟方法。

方式一：重写：
这个内容已经在上一章节详细讲过，就不再阐述，详细可访问：Java 重写(Override)与重载(Overload)。

方式二：接口
* 1. 生活中的接口最具代表性的就是插座，例如一个三接头的插头都能接在三孔插座中，因为这个是每个国家都有各自规定的接口规则，有可能到国外就不行，那是因为国外自己定义的接口类型。
* 2. java中的接口类似于生活中的接口，就是一些方法特征的集合，但没有方法的实现。具体可以看 java接口 这一章节的内容。
* 
方式三：抽象类和抽象方法




声明抽象方法会造成以下两个结果：
* 如果一个类包含抽象方法，那么该类必须是抽象类。
* 任何子类必须重写父类的抽象方法，或者声明自身为抽象类。
 
总结一下 就是 ：抽象类才有抽象方法 非抽象类的子类必须重写父类的抽象方法。


抽象类总结规定
* 1. 抽象类不能被实例化(初学者很容易犯的错)，如果被实例化，就会报错，编译无法通过。只有抽象类的非抽象子类可以创建对象。
* 2. 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类。
* 3. 抽象类中的抽象方法只是声明，不包含方法体，就是不给出方法的具体实现也就是方法的具体功能。
* 4. 构造方法，类方法（用static修饰的方法）不能声明为抽象方法。
* 5. 抽象类的子类必须给出抽象类中的抽象方法的具体实现，除非该子类也是抽象类。

Java封装的步骤

1. 修改属性的可见性来限制对属性的访问（一般限制为private）
2. 对每个值属性提供对外的公共方法访问，也就是创建一对赋取值方法，用于对私有属性的访问

Java 接口

接口，在JAVA编程语言中是一个抽象类型，是抽象方法的集合，接口通常以interface来声明。一个类通过继承接口的方式，从而来继承接口的抽象方法。
接口并不是类，编写接口的方式和类很相似，但是它们属于不同的概念。类描述对象的属性和方法。接口则包含类要实现的方法。
除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。
接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。另外，在 Java 中，接口类型可用来声明一个变量，他们可以成为一个空指针，或是被绑定在一个以此接口实现的对象。
可以implement多个接口，好像实现了多继承一样。

接口与类相似点：
* 一个接口可以有多个方法。
* 接口文件保存在 .java 结尾的文件中，文件名使用接口名。
* 接口的字节码文件保存在 .class 结尾的文件中。
* 接口相应的字节码文件必须在与包名称相匹配的目录结构中。
接口与类的区别：
* 接口不能用于实例化对象。
* 接口没有构造方法。
* 接口中所有的方法必须是抽象方法。
* 接口不能包含成员变量，除了 static 和 final 变量。
* 接口不是被类继承了，而是要被类实现。
* 接口支持多重继承。
接口特性
* 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public abstract，其他修饰符都会报错）。
* 接口中可以含有变量，但是接口中的变量会被隐式的指定为 public static final 变量（并且只能是 public，用 private 修饰会报编译错误。
* 接口中的方法是不能在接口中实现的，只能由实现接口的类来实现接口中的方法。
抽象类和接口的区别
* 1. 抽象类中的方法可以有方法体，就是能实现方法的具体功能，但是接口中的方法不行。
* 2. 抽象类中的成员变量可以是各种类型的，而接口中的成员变量只能是 public static final 类型的。
* 3. 接口中不能含有静态代码块以及静态方法(用 static 修饰的方法)，而抽象类是可以有静态代码块和静态方法。
* 4. 一个类只能继承一个抽象类，而一个类却可以实现多个接口。

接口有以下特性：

* 接口是隐式抽象的，当声明一个接口的时候，不必使用abstract关键字。
* 接口中每一个方法也是隐式抽象的，声明时同样不需要abstract关键子。
* 接口中的方法都是公有的。

重写接口中声明的方法时，需要注意以下规则：
* 类在实现接口的方法时，不能抛出强制性异常，只能在接口中，或者继承接口的抽象类中抛出该强制性异常。
* 类在重写方法时要保持一致的方法名，并且应该保持相同或者相兼容的返回值类型。
* 如果实现接口的类是抽象类，那么就没必要实现该接口的方法。
在实现接口的时候，也要注意一些规则：
* 一个类可以同时实现多个接口。
* 一个类只能继承一个类，但是能实现多个接口。
* 一个接口能继承另一个接口，这和类之间的继承比较相似。

接口之间也可以继承，接口之间的还可以实现多继承

包的作用
* 1、把功能相似或相关的类或接口组织在同一个包中，方便类的查找和使用。
* 2、如同文件夹一样，包也采用了树形目录的存储方式。同一个包中的类名字是不同的，不同的包中的类的名字是可以相同的，当同时调用两个不同包中相同类名的类时，应该加上包名加以区别。因此，包可以避免名字冲突。 
* 3、包也限定了访问权限，拥有包访问权限的类才能访问某个包中的类。

Java 使用包（package）这种机制是为了防止命名冲突，访问控制，提供搜索和定位类（class）、接口、枚举（enumerations）和注释（annotation）等。

以下是一些 Java 中的包：
* java.lang-打包基础的类
* java.io-包含输入输出功能的函数

设置 CLASSPATH 系统变量———这个经常设置用到，CLASSPATH具体是做什么的？还需要确定
用下面的命令显示当前的CLASSPATH变量：
* Windows 平台（DOS 命令行下）：C:\> set CLASSPATH
* UNIX 平台（Bourne shell 下）：# echo $CLASSPATH
删除当前CLASSPATH变量内容：
* Windows 平台（DOS 命令行下）：C:\> set CLASSPATH=
* UNIX 平台（Bourne shell 下）：# unset CLASSPATH; export CLASSPATH
设置CLASSPATH变量:
* Windows 平台（DOS 命令行下）： C:\> set CLASSPATH=C:\users\jack\java\classes
* UNIX 平台（Bourne shell 下）：# CLASSPATH=/home/jack/java/classes; export CLASSPATH

* 枚举（Enumeration）
* 位集合（BitSet）
* 向量（Vector）
* 栈（Stack）
* 字典（Dictionary）
* 哈希表（Hashtable）
* 属性（Properties）


集合框架

集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：
* 接口：是代表集合的抽象数据类型。接口允许集合独立操纵其代表的细节。在面向对象的语言，接口通常形成一个层次。
* 实现（类）：是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构。
* 算法：是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。
 
该框架也定义了几个Map接口和类。Map里存储的是键/值对。尽管Map不是collections，但是它们完全整合在集合中。


集合框架定义的一些接口：

1	Collection 接口
Collection 是最基本的集合接口，一个 Collection 代表一组 Object，Java不提供直接继承自Collection的类，只提供继承于的子接口(如List和set)。

2	List 接口
List接口是一个有序的Collection，使用此接口能够精确的控制每个元素插入的位置，能够通过索引(元素在List中位置，类似于数组的小标)来访问List中的元素，而且允许有相同的元素。

3	Set
Set 具有与 Collection 完全一样的接口，只是行为上不同，Set 不保存重复的元素。

4	SortedSet
继承于Set保存有序的集合。

5	Map
将唯一的键映射到值。

6	Map.Entry
描述在一个Map中的一个元素（键/值对）。是一个Map的内部类。

7	SortedMap
继承于Map，使Key保持在升序排列。

8	Enumeration
这是一个传统的接口和定义的方法，通过它可以枚举（一次获得一个）对象集合中的元素。这个传统接口已被迭代器取代。


集合类：
太多了

通过java.util包中定义的类：

1	Vector 
该类和ArrayList非常相似，但是该类是同步的，可以用在多线程的情况，该类允许设置默认的增长长度，默认扩容方式为原来的2倍。
2	Stack 
栈是Vector的一个子类，它实现了一个标准的后进先出的栈。
3	Dictionary 
Dictionary 类是一个抽象类，用来存储键/值对，作用和Map类相似。
4	Hashtable 
Hashtable 是 Dictionary(字典) 类的子类，位于 java.util 包中。
5	Properties 
Properties 继承于 Hashtable，表示一个持久的属性集，属性列表中每个键及其对应值都是一个字符串。
6	BitSet
一个Bitset类创建一种特殊类型的数组来保存位值。BitSet中数组大小会随需要增加。

迭代器

迭代器，使你能够通过循环来得到或删除集合的元素。ListIterator 继承了Iterator，以允许双向遍历列表和修改元素。

Java 泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

泛型的本质是 参数化类型，也就是说所操作的数据类型被指定为一个参数
不明确指定类型了，将类型泛华，类型也是一个变量。

定义泛型方法的规则：
* 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的<E>）。
* 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
* 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
* 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。


public class GenericMethodTest
{
   // 泛型方法 printArray                         
   public static < E > void printArray( E[] inputArray )
   {
      // 输出数组元素            
         for ( E element : inputArray ){        
            System.out.printf( "%s ", element );
         }
         System.out.println();
    }
 
    public static void main( String args[] )
    {
        // 创建不同类型数组： Integer, Double 和 Character
        Integer[] intArray = { 1, 2, 3, 4, 5 };
        Double[] doubleArray = { 1.1, 2.2, 3.3, 4.4 };
        Character[] charArray = { 'H', 'E', 'L', 'L', 'O' };
 
        System.out.println( "整型数组元素为:" );
        printArray( intArray  ); // 传递一个整型数组
 
        System.out.println( "\n双精度型数组元素为:" );
        printArray( doubleArray ); // 传递一个双精度型数组
 
        System.out.println( "\n字符型数组元素为:" );
        printArray( charArray ); // 传递一个字符型数组
    } 
}


有界的类型参数:
可能有时候，你会想限制那些被允许传递到一个类型参数的类型种类范围。例如，一个操作数字的方法可能只希望接受Number或者Number子类的实例。这就是有界类型参数的目的。
要声明一个有界的类型参数，首先列出类型参数的名称，后跟extends关键字，最后紧跟它的上界。

public class MaximumTest
{
   // 比较三个值并返回最大值
   public static <T extends Comparable<T>> T maximum(T x, T y, T z)
   {                     
      T max = x; // 假设x是初始最大值
      if ( y.compareTo( max ) > 0 ){
         max = y; //y 更大
      }
      if ( z.compareTo( max ) > 0 ){
         max = z; // 现在 z 更大           
      }
      return max; // 返回最大对象
   }
   public static void main( String args[] )
   {
      System.out.printf( "%d, %d 和 %d 中最大的数为 %d\n\n",
                   3, 4, 5, maximum( 3, 4, 5 ) );
 
      System.out.printf( "%.1f, %.1f 和 %.1f 中最大的数为 %.1f\n\n",
                   6.6, 8.8, 7.7, maximum( 6.6, 8.8, 7.7 ) );
 
      System.out.printf( "%s, %s 和 %s 中最大的数为 %s\n","pear",
         "apple", "orange", maximum( "pear", "apple", "orange" ) );
   }
}


泛型类
泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。
和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。


public class Box<T> {
   
  private T t;
 
  public void add(T t) {
    this.t = t;
  }
 
  public T get() {
    return t;
  }
 
  public static void main(String[] args) {
    Box<Integer> integerBox = new Box<Integer>();
    Box<String> stringBox = new Box<String>();
 
    integerBox.add(new Integer(10));
    stringBox.add(new String("菜鸟教程"));
 
    System.out.printf("整型值为 :%d\n\n", integerBox.get());
    System.out.printf("字符串为 :%s\n", stringBox.get());
  }
}

Java 序列化
java对象的序列化和反序列化
java对象 —序列化 成序列化的串。
序列化的串—反序列化 成对象。

类 ObjectInputStream 和 ObjectOutputStream 是高层次的数据流，它们包含序列化和反序列化对象的方法。

一个类的对象要想序列化成功，必须满足两个条件：
该类必须实现 java.io.Serializable 对象。
该类的所有属性必须是可序列化的。如果有一个属性不是可序列化的，则该属性必须注明是短暂的。
 
如果你想知道一个 Java 标准类是否是可序列化的，请查看该类的文档。检验一个类的实例是否能序列化十分简单， 只需要查看该类有没有实现 java.io.Serializable接口。

序列化对象
ObjectOutputStream 类用来序列化一个对象，如下的 SerializeDemo 例子实例化了一个 Employee 对象，并将该对象序列化到一个文件中。

public final void writeObject(Object x) throws IOException

public final Object readObject() throws IOException, 
                                 ClassNotFoundException


2017年3月15日
今天先到这里，明天从java网络编程继续：
http://www.runoob.com/java/java-networking.html


