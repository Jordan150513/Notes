每天一个问题1、[super init]的作用超类完成自己的初始化工作

http://www.jianshu.com/p/9b36e1b636d8
对于self ＝ [super init]的思考：

对象初始化有两种方式：[class new] 与 [[class alloc] init]
［［class alloc］ init］有分配和初始化的过程，alloc 从应用程序的虚拟地址空间上为该对象分配足够的内存，并且将新对象的引用计数加1、将对象的成员变量初始为零，init 会做真正的初使化工作，为对象的实例变量赋予合理有用的值。

[class new]默认调用 alloc与init方法，那么我们无法使用自定义的初始化方法，多了更多的局限性。那么[class alloc] init] 会更方便

为什么这样写？
- (instancetype)init
{
    if (self = [super init]) {
        // Custom initialization
    }
    return self;
}
alloc返回一个有效的未初始化的对象实例。对于self是alloc 返回的指针，同时可以在所有的方法作用域内访问。
但是对于 super，它只是一个 "编译器指示符",告诉编译器在父类中搜索方法的实现。
优先调用[super init] 是为了使超类完成它们自己的初始化工作。
if (self = [super init])
防止父类初始化失败，如果初始化一个对象失败，就会返回nil，当返回nil的时候self = [super init]测试的主体就不会再继续执行。如果不这样做，你可能会操作一个不可用的对象，它的行为是不可预测的，最终可能会导致你的程序崩溃
理解 Self & Super

@implementation Son : Father
- (id)init
{
    self = [super init];
    if (self)
    {
        NSLog(@"%@", NSStringFromClass([self class]));
        NSLog(@"%@", NSStringFromClass([super class]));
    }
    return self;
}
@end

self表示当前这个类的对象，而super是一个编译器标示符，和self指向同一个消息接受者。在本例中，无论是[self class]还是[super class]，接受消息者都是Son对象，但super与self不同的是，self调用class方法时，是在子类Son中查找方法，而super调用class方法时，是在父类Father中查找方法。
objc_msgSend（）
objc_msgSendSuper（）

类，父lei，meta class的图？？？？
找到之后补充在这里


引申：
isKindOfClass和isMemberOfClass的区别：
    QDSon * son1 = [[QDSon alloc] init];
    QDSon * son2 = [QDSon new];
    NSLog(@"%@",[son1 class]);
    NSLog(@"%d",[son1 isKindOfClass:[QDSon class]]);//1
    NSLog(@"%d", [son1 isKindOfClass:[QDFather class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDSon class]]);//1
    NSLog(@"%d",[son1 isMemberOfClass:[QDFather class]]);//0
    
    //isKindOfClass 判断 认可继承关系 判断是否是本类及子类
    //isMemberOfClass 判断 不认可继承关系 判断是否是本类
2、画圆，画圆角4+1（CC）=5中方式   第一种：使用drawRect方法绘图自定义一个View，在其drawRect方法中操作，尽量避免使用drawRect方法，会耗性能，资源浪费	- (void)drawRect:(CGRect)rect {//一个不透明类型的Quartz 2D绘画环境，相当于一个画布,你可以在上面任意绘画 //获取绘图上下文       CGContextRef context = UIGraphicsGetCurrentContext();设置各种字体颜色 格式最后用CGContextDrawPath方法，画在画布上   CGContextDrawImage画图片} 第二种：设置secondView.layer.cornerRadius = 50;    secondView.layer.masksToBounds = YES;     会引起离屏渲染第三种：使用贝塞尔曲线UIBezierPath和Core Graphics框架在图片的绘图上下文中画出一个透明的圆。增加CPU负担，增加内存开销    UIImageView *imageViewTwo = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageViewTwo.image = [UIImage imageNamed:@"imageName1.jpg"];    //开始对imageView进行画图，在透明的这个imageView的画布上开始画    UIGraphicsBeginImageContextWithOptions(imageViewTwo.bounds.size, NO, [UIScreen mainScreen].scale);//    UIGraphicsBeginImageContextWithOptions(<#CGSize size#>, <#BOOL opaque#>, <#CGFloat scale#>)    //opaque：不透明    //使用贝塞尔曲线画出一个圆形图，并且切掉其他的，就剩下了透明的想要的那个圆    [[UIBezierPath bezierPathWithRoundedRect:imageViewTwo.bounds cornerRadius:imageViewTwo.frame.size.width] addClip];//    + (instancetype)bezierPathWithRoundedRect:(CGRect)rect cornerRadius:(CGFloat)cornerRadius;     //rounds all corners with the same horizontal and vertical radius    [imageViewTwo drawRect:imageViewTwo.bounds];        imageViewTwo.image = UIGraphicsGetImageFromCurrentImageContext();    //结束画图    UIGraphicsEndImageContext();    [self.view addSubview:imageViewTwo];          第四种：使用CAShapeLayer和UIBezierPath设置圆角，设置view.layer.mask同样会触发离屏渲染。    UIImageView *imageView = [[UIImageView alloc]initWithFrame:CGRectMake(100, 100, 100, 100)];    imageView.image = [UIImage imageNamed:@"imageName1.jpg"];        UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:imageView.bounds byRoundingCorners:UIRectCornerAllCorners cornerRadii:imageView.bounds.size];        CAShapeLayer *maskLayer = [[CAShapeLayer alloc]init];    //设置大小    maskLayer.frame = imageView.bounds;    //设置图形样子    maskLayer.path = maskPath.CGPath;    imageView.layer.mask = maskLayer;        [self.view addSubview:imageView];第五种：CC的方法，addsubLayerUIImageView * imageView = [[UIImageView alloc] initWithFrame:CGRectMake(0, 0, 80, 80)];            [imageView setImage:[UIImage imageNamed:@"AppIcon60x60"]];            CAShapeLayer * layer = [CAShapeLayer layer];            UIBezierPath * path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 80, 80)];            UIBezierPath * circlePath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(0, 0, 80, 80)];            [path appendPath:circlePath];            [path setUsesEvenOddFillRule:YES];            [path addClip];            layer.path = path.CGPath;//            layer.fillColor = [UIColor whiteColor].CGColor;//改成跟北京色一致的            layer.fillColor = [UIColor colorWithRed:240/255.f green:240/255.f blue:240/255.f alpha:1].CGColor;            layer.fillRule = kCAFillRuleEvenOdd;            [imageView.layer addSublayer:layer];            [cell.contentView addSubview:imageView]; 第六种：混合两个imageView，遮盖下面的那个，形成圆角需要切图配合，更直接的，就直接让切图给一个圆角图就可以了。总结：尽量避免重写 drawRect 方法。不恰当的使用这个方法会导致内存暴增。举个例子，iPhone6 上与屏幕等大的 UIView，即使重写一个空的 drawRect 方法，它也至少占用 750 * 1134 * 4 字节 ≈ 3.4 Mb 的内存。在 内存恶鬼drawRect 及其后续中，作者详细介绍了其中原理，据他测试，在 iPhone6 上空的、与屏幕等大的视图重写 drawRect 方法会消耗 5.2 Mb 内存。总之，能避免重写 drawRect 方法就尽可能避免。最基础的一种UIView.layer.cornerRadiusmaskToBounse =yes设置 masksToBounds 会导致离屏渲染，出现性能降低 label 的四周出现了黄色的标记，说明这里出现了离屏渲染高效设置圆角为普通的 UIView设置圆角，和为 UIImageView 设置圆角的原理截然不同。有什么不同？离屏渲染：指的是GPU在当前屏幕缓冲区以外新开辟一个缓冲区进行渲染操作。iOS 9.0 之前UIimageView跟UIButton设置圆角都会触发离屏渲染iOS 9.0 之后UIButton设置圆角会触发离屏渲染，而UIImageView里png图片设置圆角不会触发离屏渲染了，如果设置其他阴影效果之类的还是会触发离屏渲染的。3、tabBar左右滑动的问题再由tabBar的页面左右，左右滑动的时候，有时候，tabbar不能跟着页面滑动？
4、tableView加timer    什么情况下，timer不能正常的释放掉，什么可以使timer正常的释放掉。见YYFPSLabel的实现。
常见会有bug，tableview滚动会影响timer，tableview滚动的时候，咱阻塞timer，这说明timer添加到的RunLoop的mode不对，需要提高model的优先级，
有三个mode：
NSDefaultRunLoopMode - 标准优先级
NSRunLoopCommonModes - 高优先级
UITrackingRunLoopMode - 用于UIScrollView和别的控件的动画
5、客户详情的右上角的聚合按钮6、keyWindow的问题见仿写iOS系统的浮动聚合按钮的demo？？8、mjrefresh实现9、ASI   AFN10、srwebsocket  内部实现   保活机制12、界面等比放大13、ARC 下 viewdidload 中定义的变量什么时候会释放14、数据库升级
15、uicontrol   uiresponse16、block  为啥不能修改局部变量17、内存管理  strong weak18、自动释放池  三个，加到哪一个19、KVC   KVO20、栈和堆21、static  22、http  和  https23、iOS目录结构24、framework   .a   静态库和动态库25、socket26、bitcode27、死锁产生的条件，怎么避免四个必要条件：互斥条件    请求与保持   不剥夺条件    循环等待条件28、TCP和UDP29、userdefault  存储的数据能通过物理路径找到吗31、深入理解RunLoop32、深入理解GCD
见GCDNotes.txt里面包括了1和2

3：dispatch source
4：dispatch queue挂起和dispatch queue目标锁定和信号量 
33、定时帧NSTimer和CADisplayLink
见博客http://www.cnblogs.com/Jordandan/p/6197273.html
定时帧
30、获取帧率见YYFPSLabel的实现，博客的记录

31、block中修改变量的问题
